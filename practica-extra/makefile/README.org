#+TITLE: Makefile
* Conceptos
  - Se utiliza ~make~ para cualquier proyecto con *dependencias* entre archivos (no solo para ejecutar ~gcc~)
  - En ~C~ la relación de dependencia es
    1. Los ejecutables dependen de los archivos ~.o~
    2. Los  ~.o~ dependen de su ~.c~ y de los ~.h~ que incluyan los ~.c~

  *Observaciones:*
  - Los archivos ~.o~ se conocen por *objetos*
  - Los ~.h~ como archivos cabecera, se incluyen declaraciones de estructuras, variables globales y funciones (prototipos/firmas)
  - Los ~.c~ son el código fuente, el que tiene la lógica del programa
* Reglas
** Conceptos
   + Si una regla tiene archivos en las [[Dependencias]] que también son [[Target]] de otras reglas
     1. Se ejecuta la regla donde aparece como ~target~
     2. Luego la regla donde aparece como ~dependencia~

  #+BEGIN_SRC makefile
    # La forma general de cada regla es de la forma
    target: dependencias
      comando1
      comando2
  #+END_SRC
* Target
** Conceptos
   - Cada *target* representa el nombre del archivo que se genera, luego de cumplirse la regla
   - Debe ser recompilado cuando cambien las dependencias
** Target Final
   + Es la primera regla del makefile y tiende a ser el ejecutable
   + Es el último *target* en el *árbol de dependencias* por tanto el último que se ejecuta
** Falso target
*** Conceptos
    + No se les suele agregar [[Dependencias]]
    + Cuando queremos que la regla se ejecute siempre
    + Es un target que no existe (porque un target tiende a representar un archivo existente)
    + El ~make~ nota que no existe el archivo, y ejecuta los comandos que generan la regla

    #+BEGIN_QUOTE
    Un posible problema sería si agregamos un *falso target* y en el directorio existe un 
    fichero con ese nombre.
    Porque al no tener *dependencias* el ~make~ interpretará que el archivo está actualizado,
    y no ejecutará los *comandos* de la *regla*
    La solución a esto es utilizar ~PHONY~ (representa a un *target ficticio*)
    #+END_QUOTE
*** Ejemplos
    #+BEGIN_SRC makefile
      # este es un ejemplo típico de un "falso target", que borra los archivos .o de fichero c compilado
      # - porque "clean" no es un archivo en si (no debería)
      # - la regla tampoco tiene dependencia (lo que se agrega seguido de los dos puntos)
      clean:
        rm *.o

      # Podemos usar .PHONY
      # para evitar problemas si llegase a existir un archivo "clean"
      .PHONY: clean
      clean:
        rm *.o
    #+END_SRC
** Target Ficticio - Phony
*** Conceptos
    Con ~PHONY~ se soluciona el problema de los *falsos target* si llegase a existir un archivo 
    con el mismo nombre que el target

    #+BEGIN_QUOTE
    Cuando a un *falso target* le agregamos como dependencia otro *falso target*
    la regla siempre se cumple. Por tanto podemos usar los *falsos targets*
    como subrutinas a ejecutar.
    #+END_QUOTE
*** Ejemplo 1 - Limpiar archivos compilados
    #+BEGIN_SRC makefile
      # Si usamos .PHONY
      # evitamos problemas si llegase a existir un archivo "clean"
      # (osea que un fichero con el mismo nombre que el "falso target")
      .PHONY: clean
      clean:
        rm *.o
    #+END_SRC
*** Ejemplo 2 - Compilar programas
    #+BEGIN_SRC makefile
      .PHONY: all
      all: programa1, programa2

      programa1: main.o archivo1.o archivo2.o
        gcc -o programa1 main.o archivo1.o archivo2.o

      programa2: main.o archivo1.o archivo3.o
        gcc -o programa2 main.o archivo1.o archivo3.o
    #+END_SRC
*** Ejemplo 3 - Subrutinas
    Este ejemplo lo podemos ejecutar con ~makefile cleanall~
    donde se ejecutarán las subrutinas de borrar los archivos de tipo object
    y luego los de texto

    #+BEGIN_SRC makefile
      .PHONY: cleanall cleanobj cleantxt
      cleanall: cleanobj cleantxt
        rm miprograma

      cleanobj:
        rm *.o

      cleantxt:
        rm *.txt
    #+END_SRC
** Target de Seguimiento
*** Conceptos
    - Representan *depedencias* pero de archivos reales, contienen la fecha y hora de creación (timestamp)
    - El ~$?~ se *expande* por las *dependencias* (osea archivos) cuyo *timestamp* sea más reciente
*** Ejemplo
    Suponiendo que ya habiamos creado los archivos main.c, jugadores.c, items.c
    1. Ejecutamos el make imprime_actualizados y se construirá el ejecutable imprime_actualizados
    2. Si modificamos alguno de los .c y volvemos a ejecutar el comando anterior, se imprimirá sólo aquellos modificados
       y se volverá a crear el ejecutable imprime_actualizados

    *Observación:*
    En este ejemplo el ~$?~ se expande por los archivos más recientes que ~imprime_actualizados~

    #+BEGIN_SRC makefile
      # - con "cat" imprimimos contenido de un archivo
      # - el $? se expande con los archivos de timestamp mas reciente que imprime_actualizados
      # - imprimimos el contenido de los archivos actualizados/modificados
      # es decir su timestamp es más reciente que el del archivo imprime_actualizados
      imprime_actualizados: main.c jugadores.c items.c
        cat $?
        touch imprime_actualizados
    #+END_SRC
* Dependencias
** Conceptos
   - Representa a uno o varios archivos cuyo *timestamp* (fecha y hora de creación) se debe
     comprobar para ver si son más modernos (porque fue actualizado/modificado) que el archivo a construir
   - Si se cumple que el *timestamp* es más moderno que el archivo a construir
     entonces se construye ó reconstruye
* Comandos
** Conceptos
  - Los *comandos* se ejecutan cuando se cumple la regla
  - Deben empezar por *tabulador* (si nos olvidamos, habrán errores)
** Tener varios makefiles
   Por lo general se puede tener sólo un archivo *Makefile* pero podemos utilizar el 
   parámetro ~-f~ ó ~--file~ para ejecutar un archivo *Makefile2* ó *Makefile2*

   #+BEGIN_SRC shell
     # suponiendo que tenemos un segundo makefile
     make -f Makefile2

     # la otra alternativa es
     make --file=Makefile3
   #+END_SRC
** Ejecutar ignorando errores
   Si alguno de los comandos falla, también falla la construcción del make.
   Para evitar esto podemos agregar el guión ~-~ previo al comando a ejecutar.
   De esta manera si falla y lanza algún error el comando, se sigue ejecutando.

   #+BEGIN_SRC makefile
     # este era el caso típico que solíamos hacer
     # si por algún motivo falla el rm, no continúa borrando
     # (Ej. no encuentra algún archivo .o)
     .PHONY: clean
       clean:
       rm *.o

     # SOLUCION HERE..!
     # Si falla el rm por mismos motivos que el de arriba
     # no importa, seguirá ejecutandose borrando los que falten
     .PHONY: clean
       clean:
       -rm *.o	# acá estamos agregando el guión.. :)
   #+END_SRC
** Simular ejecución
   Si queremos sólo mostrar que comandos ejecutaría el comando ~make~
   podemos pasarle el parámetro ~-n~ quedando.. ~make -n~
   Esto nos imprimirá los comandos que ejecutaría, pero sin hacerlo realmente.

   Un ejemplo de esto podría ser compilar un programa de C

   #+BEGIN_EXAMPLE
   > make -n
   gcc -c jugadores.c
   gcc -c main.c
   gcc -o programa main.o jugadores.o
   #+END_EXAMPLE
* Ejemplos
** Expresividad - Lineas muy extensas
   Si tenemos lineas muy extensas podemos usar el carácter ~\~ al igual que en ~bash~
   
   #+BEGIN_SRC makefile
     main.o: main.c players.h monsters.h items.h \
     configs.h events.h messages.h
   #+END_SRC
** Generar varios ejecutables
   - Podemos usar ~all~ (se considea un *falso target*) cuando tenemos reglas para varios ejecutables,
   - Si no agregamos este target, sólo se ejecutará la regla 1
     (porque es el target final, y la regla 2 no es una dependencia de ella)

   *Observación:*
   El ~make~ siempre considera la primera regla como el [[Target Final]] (el ejecutable),
   y si la "regla 2" NO es una *dependencia* de esa primera regla, entonces no lo ejecutará.

   #+BEGIN_SRC makefile
     # hacemos que se ejecuten ambos por separado
     # porque no dependen entre ellos
     all: programa1 programa2

     # regla 1
     programa1: main.o players.o items.o
       gcc -o programa1 main.o players.o items.o

     # regla 2
     programa2: server.o configs.o
       gcc -o programa2 server.o configs.o
   #+END_SRC
** Comandos en Shell diferentes
   Cada comando se ejecuta en una ~shell~ diferente
   
   #+BEGIN_SRC makefile
     programa: players/items.c
       cd players;\   # se ejecuta en una shell
       gcc -c items.c # se ejecuta en otra shell
   #+END_SRC
** Prioridad entre target y dependencia
  - Los *targets* son main.o, players.o, monsters.o
  - El ~main.o~ aparece en dos reglas
    1. En la primera regla aparece como *dependencia*
    2. En la segunda regla aparece como *target* (esta se ejecutará primero)

 #+BEGIN_SRC makefile
   juegito: main.o players.o monsters.o
     gcc -o juegito main.o players.o monsters.o

   main.o: main.c players.h players.c monsters.o
     gcc -c main.c

   players.o: players.c players.h
     gcc -c players.c

   monsters.o: monsters.c monsters.h
     gcc -c monsters.c
 #+END_SRC
* Referencias
  1. http://profesores.elo.utfsm.cl/~agv/elo320/makefile/makefile.html
  2. https://www.zator.com/Cpp/E1_4_0a.htm
