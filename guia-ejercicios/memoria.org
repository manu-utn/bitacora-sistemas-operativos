#+TITLE: Guia Ejercicios - Memoria
#+STARTUP: inlineimages
* Conceptos Básicos
** Referencias
   1. https://www.rapidtables.com/convert/number/hex-to-decimal.html
   2. http://cv.uoc.edu/UOC/a/moduls/90/90_574b/web/main/m1/c1/4.html

   pendientes a revisar si dejar
   1. http://ryan.gulix.cl/dw/miscelaneos/notacion_de_bytes
   2. https://es.stackoverflow.com/questions/175436/por-qu%C3%A9-2-elevado-a-n-el-resultado-est%C3%A1-en-bytes
** Tips
*** Diferenciar bits de un hexadecimal
   Si nos dan el hexadecimal ~0BEEFh~ para representarlo el *binario*...
   recordemos que cada valor *hexadecimal* equivale a ~4 bits~,
   que en binario podría ser cualquiera de estos valores.. 0000, 0001, 1000, etc..

   La ~h~ sólo hace referencia a que la expresión dada, es *hexadecimal*

   ~0BEEFh~ equivale a ~0000 1011 1110 1110 1111~ en binario

   - B (hexadecimal) = 11 (decimal) = 2^3*1 + 2^2*0 + 2^1 + 2^0 (potencias de 2) = 1011 (binario) = 4 bits
   - F (hexadecimal) = 15 (decimal) = 2^3*1 + 2^2*1 + 2^1*1 + 2^0*1 (potencias de 2) = 1111 (binario) = 4 bits

   |-------------+--------+------------+--------------+--------+--------------|
   | Decimal     |        | 11=8+0+2+1 | 14 (8+4+2+0) |     14 | 15 (8+4+2+1) |
   |-------------+--------+------------+--------------+--------+--------------|
   | Hexadecimal |      0 | B          | E            |      E | F            |
   |-------------+--------+------------+--------------+--------+--------------|
   | Binario     |   0000 | 1011       | 1110         |   1110 | 1111         |
   |-------------+--------+------------+--------------+--------+--------------|
   |             | 4 bits | 4 bits     | 4 bits       | 4 bits | 4 bits       |
   |-------------+--------+------------+--------------+--------+--------------|

   Retomando el ejemplo anterior
   - Si nos piden los primeros 4 bits del hexadecimal sería ~0~
   - Si nos piden los primeros 2 bits serían ~00~
   - Si nos piden los ultimos 16 bits en binario serían ~1011 1110 1110 1111~ (nos salteamos el ~0000~)
   - Si nos piden los últimos 16 bits en hexadecimal ~BEEF~
*** Bits de relleno al comienzo
    Si tenemos el hexadecimal ~0BEEFh~ y sabemos que en binario 
    equivale a ~0000 1011 1110 1110 1111~
    
    Podes obviar/ignorar los primeros 4 bits ~0000~ porque son de relleno

    *IMPORTANTE...!:*
    Si ese ~0000~ estuviese al final, NO PODEMOS IGNORARLOS. porque nos daría
    otro valor en binario...

    Ej.:
    ~0001~ equivale al ~1~ en hexadecimal, el ~0011~ al ~3~, el ~1100~ al ~C~
    En el ~0011~ podemos ignorar los primeros ceros,
    En el ~1100~ NO PODEMOS IGNORAR los ultimos ceros
** Unidades Básicas
*** Bit (b)
    - Representa la _unidad básica de almacenamiento_ de información digital
    - 8 bits representa 1 Bytes
    - Se representa con la *b* (minúscula)
*** Byte (B)
    - Representa a una _unidad de memoria direccionable_
    - 8 bits representa 1 Bytes
    - Se representa con la *B* (mayuscula)
    - Rangos
      - En binario entre 00000000 y 11111111
      - En decimal entre 0 y 255
      - En hexdecimal entre 00 y FF
*** Kibibyte (KiB)
    - Representa a _una unidad que es multiplo del byte_ y equivale a 2^10
** Bits de Mayor y Menor Peso
   + (MSB): El bit *mayor significativo* se lo conoce como *el de mayor peso* (ó valor)
   + (LSB): El bit *menos significativo* es conocido por *el de menor peso* (ó valor)
   
   #+BEGIN_QUOTE
   En un *byte* el *bit* de mayor peso es el que está en la posición 7
   y el de menor peso el de la posición 0
   #+END_QUOTE

   |-------+-----+-----+-----+-----+-----+-----+-------|
   | 1     |   0 |   1 |   0 |   0 |   1 |   0 | 1     |
   |-------+-----+-----+-----+-----+-----+-----+-------|
   | bit   | bit | bit | bit | bit | bit | bit | bit   |
   | ~MSB~ |     |     |     |     |     |     | ~LSB~ |
   |-------+-----+-----+-----+-----+-----+-----+-------|
** Tablas de Conversiones
   La potencia 2^N ese N representa la cant. de ~bits~ es decir 2^(N bits)

   |---------+---------+------------|
   | (B)ytes | (b)its  | en binario |
   |---------+---------+------------|
   | 1 Byte  | 8 bits  |            |
   | 2 Bytes | 16 bits |            |
   |---------+---------+------------|

   |-------+---------+----------------------------------------------------------------------------|
   | KiB   | bits    | bytes                                                                      |
   |-------+---------+----------------------------------------------------------------------------|
   | 1 Kib | 10 bits | 2^10 = 1024 bytes (1024 combinaciones para representar valores diferentes) |
   |-------+---------+----------------------------------------------------------------------------|

   #+name: hexadecimal-binario
   |--------------+-----------+-------------+-----------------------------|
   |  Hexadecimal |   Decimal |     Binario |                             |
   | (en base 16) | (base 10) | (en base 2) |                             |
   |--------------+-----------+-------------+-----------------------------|
   |            1 |         1 |        0001 | 2^0                         |
   |            2 |         2 |        0010 | 2^1 + 2^0                   |
   |            3 |         3 |        0011 | 2^1 + 2^0                   |
   |            4 |         4 |        0100 | 2^2 + 0*2^1 + 0*2^0         |
   |            5 |         5 |        0101 | 2^2 + 0*2^1 + 2^0           |
   |            6 |         6 |        0110 | 2^2 + 2^1   + 0*2^0         |
   |            7 |         7 |        0111 |                             |
   |            8 |         8 |        1000 | 2^3 + 0*2^2 + 0*2^1 + 0*2^0 |
   |            9 |         9 |        1001 |                             |
   |            A |        10 |        1010 |                             |
   |            B |        11 |        1011 |                             |
   |            C |        12 |        1100 |                             |
   |            D |        13 |        1101 |                             |
   |            E |        14 |        1110 |                             |
   |            F |        15 |        1111 |                             |
   |--------------+-----------+-------------+-----------------------------|
   |              |           |             |                             |
** Ejemplos de Conversión
*** Hexadecimal a binario
   1. A1 es 1010 0001 <-- Conversión: (2^3 + 2^1)  (2^0)
   2. AA es 1010 1010 <-- Conversión: (2^3 + 2^1)  (2^0)

   Recordamos la tabla de conversión donde 1 hexadecimal se puede representar con ~4 bits~,
   y que sumamos los múltiplos de 2 (lo podemos ver similar a un polinomio de grado 3),
   donde en la suma multiplicamos por 1 sólo aquellos que nos interesa su valor,
   y el resto por cero.

   1111 = 2^3 + 2^2 + 2^1 + 2^0 = 8+4+2+1 = F (15 en hexadecimal)

   |-------+-------+-------+-------|
   |  1000 |  0100 |  0010 | 0001  |
   |-------+-------+-------+-------|
   | 2^3=8 | 2^2=4 | 2^1=2 | 2^0=1 |
   |-------+-------+-------+-------|
*** Decimal a binario
    1. 3 es 001 <-- Conversión: 2^1 
    2. 9 es 101 <-- Conversión: 2^3 + 2^1 = 8 + 1
** Potencias de 2
   - El sistema de numeración binario (ó en base 2) se representa con *potencias de 2*
   - El exponente ~N~ de ~2^N~ representan los ~bits~ de información (max. longitud del valor que se puede generar)

     |-------+----------------------+--------------------------------------------------------------------|
     |       | Cant. de información | para representar X cantidad de valores distintos ó combinaciones   |
     |-------+----------------------+--------------------------------------------------------------------|
     | ~2^1~ | ~1 bit~              | ~2^1=2~ => 2 combinaciones para representar valores (0 y 1)        |
     | ~2^2~ | ~2 bits~             | ~2^2=4~ => 4 valores posibles (00, 01, 10, 11)                     |
     | ~2^3~ | ~3 bits~             | ~2^3=8~ => 8 valores posibles  (000, 001, 010, 100, 101, 110, 111) |
     |-------+----------------------+--------------------------------------------------------------------|

   #+BEGIN_QUOTE
   De ~2^10~ tenemos ~10 bits~ de información = 1024 Bytes (1024 combinaciones)
   Se necesitan ~10 bits~ para representar 1024 elementos distintos

   Otro ejemplo es ~2^8~ donde ~8 bits~ equivale a ~1 Byte~
   ~2^8~ necesitamos ~8 bits~ de información para representar 2^3 = 256 valores diferentes
   #+END_QUOTE

   #+BEGIN_QUOTE
   Los binarios 1000, 1100, 1001, 1010 equivalen a ~4 bits~
   
   Si tenemos el valor ~1111~ en binario equivale a ~4 bits~
   2^3*1 + 2^2*1 + 2^1*1 + 2^0*1 = 8 + 4 + 2 + 1 = ~15~ en Decimal, ~Fh~ e Hexadecimal
   
   Por tanto si tenemos el binario ~1000~
   equivale a ~8h~ en Hexadecimal porque (2^3*1 + 2^2*0 + 2^1*0 + 2^0*0 = 8 + 0 + 0 + 0 es 8)
   #+END_QUOTE
** Tamaño entre DL y DF
   - Puede pasar que la *dirección lógica* (DL) sea del mismo tamaño que la *dirección física* (DF)
     (/En este caso tenemos un proceso que ocupa tanto como el tamaño de la memoria principal/)
   - El tamaño es siempre DL <= DF (puede ser igual o menor)
** Segmentación
   - Para calcular la dirección física (DF): ~direccion_fisica = base + offset~
   - Para calcular el número de segmento: ~numero_segmento = Base / Limite~ (lo mismo aplica para paginación)
** Direccionamiento Logica y Fisica
   - Definir Dirección lógica: ~direccion_logica = numero_pagina | offset~ ??? porque el | ?
   - Definir la dirección física: ~direccion_fisica = numero_marco | offset~ ??? porque el | ?
** Tamaño de Marco
   Si sabemos la cant. de marcos => Será la potencia de 2 que resulte en la cant. de marcos
   (/Ej. si la memoria física tiene 32 marcos => 2^5 = 32 => los marcos son de 5 bits/)
** Tamaño de Pagina
   Si sabemos el tamaño de página => Será la potencia de 2 que resulte en ese tamaño
   (/Ej. si el tamaño de página es 1Kib => 1Kib=10 bits porque 2^10bits=1024 bytes/)

   *Observación:*
   Si sabemos el tamaño del marco => ~tamanio_pagina = tamanio_marco~
** Tamaño de Memoria fisica
   Si sabemos la cant de marcos => Será la cant. de marcos * tamaño de marco (ó de página)
   (/Ej. si la ram tiene 32 marcos, y c/página es de 1Kib => 32*KiB=32Kib=>2^15bits => memoria=15bits/)
* Ejercicio 1
  #+BEGIN_QUOTE
  Considere el espacio de ~direccionamiento lógico~ de 8 ~páginas~ de 1024 bytes cada una, mapeado en una ~memoria física~
  de 32 ~frames~.
  #+END_QUOTE

  1. ¿Cuántos bits hay en la dirección lógica?
  2. ¿Cuántos bits hay en la dirección física?
  3. En un esquema de paginación sin memoria virtual, ¿Como tendría que ser la relación entre los tamaños de las
     direcciones calculadas anteriormente? (dirección lógica menor, igual o mayor que dirección física)
** Respuesta
   1. 

* Ejercicio 1
  #+BEGIN_QUOTE
  #+END_QUOTE

** Respuesta
* Ejercicio 1
  #+BEGIN_QUOTE
  #+END_QUOTE

** Respuesta
* Ejercicio 1
  #+BEGIN_QUOTE
  #+END_QUOTE

** Respuesta
* Ejercicio 1
  #+BEGIN_QUOTE
  #+END_QUOTE

** Respuesta
* Ejercicio 1
  #+BEGIN_QUOTE
  #+END_QUOTE

** Respuesta
* Ejercicio 1
  #+BEGIN_QUOTE
  #+END_QUOTE

** Respuesta


