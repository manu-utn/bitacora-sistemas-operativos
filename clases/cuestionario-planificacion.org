#+STARTUP: inlineimages
* Cuestionario (1)
** Pregunta (1)
   #+BEGIN_QUOTE
   V/F
   ¿En caso de utilizar jacketing sería lo mismo utilizar ULTs/KLTs?
   #+END_QUOTE
*** Respuesta Correcta
    F
*** Justificación Respuestas Incorrectas
*** Observaciones
    Ya que el SO sigue sin "ver" dichos ULTs no puede planificarlos (ej, asignarles un Q, o ejecutarlos en distintas CPUs)
    Recordar que lo único que soluciona jacketing es que el KLT/Proceso asociado a los ULTs no se bloquee y la biblioteca pueda planificar otro ULT en caso de tener alguno LISTo.
** Pregunta (2)
   #+BEGIN_QUOTE
   Indique cuáles de las siguientes afirmaciones son VERDADERAs sobre planificación con biblioteca de ULTs
   
   1. Si hay varios KLTs con ULTs todos los KLTs deben usar la misma biblioteca de ULTs
   2. Si decidimos usar ULTs es igual de útil usar directo syscalls (ej write) que usar los wrappers de las sycalls provistas por la biblioteca
   3. Cuando un ULT necesita realizar una IO se lo pide al SO con una syscall. En este caso, el SO puede diferenciar cuál ULT lo está pidiendo.
   4. Todas son correctas
   5. Ninguna es correcta
   #+END_QUOTE
*** Respuesta Correcta
   - Ninguna es correcta
*** Justificación Respuestas Incorrectas
*** Observaciones
    Son todas falsas:
    - Cada KLT puede usar una biblioteca distinta, y por ende tener distintos criterios de planificación
    - Si llamamos directo a syscalls bloqueantes desde el código de nuestros ULTs no permitimos que la biblioteca replanifique cuando sea necesario para el algoritmo usado
    - El SO no "ve" ni sabe de la existencia de los ULTs, cuando le llega el pedido de una sycall, sólamente sabe que vino de una entidad de planificación que conoce, como un KLT o un proceso
** [#A] Pregunta (3)
   #+BEGIN_QUOTE
   Un proceso posee 3 KLTs y cada uno 3 ULTs asociados.
   Si un ULT necesita hacer una syscall bloqueante (ej read) ...
   ¿cuáles de las siguientes afirmaciones PODRÍAN ser ciertas?

   1. Por default todo el KLT se bloquea
   2. Por default todo el KLT y el proceso asociado se bloquean
   3. Podría no bloquearse todo el KLT <- Ojo..!
   4. Al finalizar la operación bloqueante y ser seleccionados por el planificador del SO vuelve a ejecutar el mismo ULT
   5. Al finalizar la operación bloqueante y ser seleccionados por el planificador del SO ejecuta el ULT que seleccione la biblioteca de ULTs <- Ojo..!
   #+END_QUOTE
*** Respuesta Correcta
    Todas
*** Justificación Respuestas Incorrectas
*** Observaciones
    El SO por default "ve" que la syscall llega del KLT asociado, por lo que lo bloquea.
    Por otro lado, en caso de utilizar jacketing, podría ejecutar otro ULT del mismo KLT sin bloquearse.
    Luego de finalizar la operación bloqueante:
    - Si se realizó la syscall directo -> va a continuar con el ULT que hizo la llamada
    - Si se realizó la _syscall desde una función wrapper de la biblioteca_ -> la bilioteca podrá seleccionar al siguiente ULT a ejecutar
      (que igualmente podría ser el que originó la llamada)
    - _En caso de que justo el último KLT de un proceso se bloquee, quedaría todo el proceso en estado bloqueado_
** [#A] Pregunta (4)
   #+BEGIN_QUOTE
   V o F.
   En caso de elegir usar ULTs con jacketing vs KLTs, la única desventaja sería no poder aprovechar el multiprocesamiento.
   #+END_QUOTE
*** Respuesta Correcta
    Falso
*** Justificación Respuestas Incorrectas
*** Observaciones
    Otra desventaja es que en caso de tener un algoritmo con quantum, todos los ULTs deberán compartirlo vs en un esquema con KLTs cada uno recibiría 1 Q
** [#A] Pregunta (5)
   #+BEGIN_QUOTE
   Considere el siguiente sistema en el que en un momento (está empezada la ejecución) tenemos el siguiente estado.
   Sabiendo que el SO planifica con SJF, que el estimado anterior de KAA fue 3 y que los 3 ULTs ya estaban ready.
   Responda cuáles de las siguientes afirmaciones son verdaderas. (aclaración alpha = 0,5)
   Fórmula SJF: ~prox_est = raf_ant*alfa + (1-alfa)*ant_est~

     1. El próximo estimado de KAA será 4
     2. KAA nunca llega a bloquearse
     3. KAA utiliza una biblioteca de ULTs con jacketing
     4. La biblioteca de ULTs de KAA utiliza SJF
   #+END_QUOTE

   [[./img/gantt-naty1.png]]
*** Respuesta Correcta
    - El próximo estimado de KAA será 4
    - KAA utiliza una biblioteca de ULTs con jacketing
*** Justificación Respuestas Incorrectas
*** Observaciones
    - Como el estimado anterior fue de 3, y ejecutó 5 unidades hasta bloquearse (entre todos los ults) su próximo estimado es de (3+5)/2
    - Hay un momento en el que todos los ULTs están bloqueados, por lo que el KLT se bloquea (la biblioteca no tiene nada más para ejecutar)
    - La biblioteca de KAA usa jacketing ya que vemos que hay un ULT ejecutando mientras otro realiza una IO
    - No podemos afirmar que la biblioteca de KAA utilice SJF ya que depende un poco de los estimados, bien podría ser FIFO
* Cuestionario (2)
** Pregunta (1)
   #+BEGIN_QUOTE
   ¿Cuál es el planificador que es más importante que tenga menos overhead?

   1. El encargado de admitir nuevos procesos al sistema (PLP)
   2. El encargado de hacer swapping (PMP)
   3. El encargado de poner procesos en ejecución (PCP)
   #+END_QUOTE
*** Respuesta Correcta
   - (3) El encargado de poner procesos en ejecución (PCP)
*** Justificación Respuestas Incorrectas
*** Observaciones
    El planificador de corto plazo, el encargado de seleccionar procesos para ejecutar,
    es el que va a ejecutarse muy seguido por lo que es necesario que tome buenas decisiones
    y que tenga el menor overhead posible.
** Pregunta (2)
   #+BEGIN_QUOTE
   ¿Qué es el tiempo de espera?
   
   1. El tiempo en el que el proceso está en la cola de bloqueado
   2. El tiempo en el que el proceso no está en ejecución
   3. El tiempo en el que el proceso está en la cola de listos
   4. El tiempo en el que el proceso está en suspendido
   #+END_QUOTE
*** Respuesta Correcta
   - (3) El tiempo en el que el proceso está en la cola de listos
*** Justificación Respuestas Incorrectas
*** Observaciones
    El tiempo en el que le negamos CPU al proceso, podríamos haberlo elegido para ejecutar, pero el planificador seleccionó a otro.
** Pregunta (3)
   #+BEGIN_QUOTE
   ¿Cuál/es de las siguientes afirmaciones son falsas sobre FIFO?
   
   1. Podría permitir que un proceso monopolice la CPU
   2. Podría ser útil para correr procesos secuenciales
   3. Minimiza los cambios de contexto
   4. Todas
   5. Ninguna
   #+END_QUOTE
*** Respuesta Correcta
   1. Ninguna
*** Justificación Respuestas Incorrectas
*** Observaciones
    Al no tener desalojo, se espera a que el proceso voluntariamente libere la CPU,
    esto potencialmente podría generar que un proceso nunca la libere.
    En un contexto en el que se quiere correr un lote de procesos en forma batch
    minimizando el overhead, es una buena opción.
    
    _Al ejecutar un proceso después del otro minimiza la replanificación y por ende los cambios de contexto._
** [WAITING] [#A] Pregunta (4)
   #+BEGIN_QUOTE
   Indique cuál de las siguientes afirmaciones son correctas sobre SJF
   
   1. Puede implementarse con o sin desalojo
   2. Minimiza el tiempo de espera promedio
   3. Para poder optimizarlo se puede utilizar la media exponencial
   4. Prioriza a los procesos CPU Bound
   5. Es un algoritmo con poco overhead
   #+END_QUOTE
*** Respuesta Correcta
   1. Puede implementarse con o sin desalojo
   2. Minimiza el tiempo de espera promedio
*** Justificación Respuestas Incorrectas
*** Observaciones
    La media exponencial es necesaria para poder implementarlo ya que uno
    no podría predecir las siguientes ráfagas, sólo puede estimarlas.
    
    _Prioriza a los procesos IO Bound._
    
    #+BEGIN_COMMENT
    puede ser que me haya equivocado con lo de io-bound? no es cpu-bound?
    
    el hrrn es el que prioriza io-bound, porque a mayor tiempo de espera => mas prioridad tiene
    #+END_COMMENT
    
    _Tiene bastante overhead por el cálculo de la media exponencial, aún más si es con desalojo._
** Pregunta (5)
   #+BEGIN_QUOTE
   V o F . HRRN podría implementarse con o sin desalojo según cómo se prefiera
   #+END_QUOTE
*** Respuesta Correcta
    Falso
*** Justificación Respuestas Incorrectas
*** Observaciones
    Como tiene en cuenta la variable "tiempo de espera", en caso de implementarlo
    con desalojo habría que estar replanificando con cada instante que pasa,
    generando demasiado overhead.
** [#A] Pregunta (6)
   #+BEGIN_QUOTE
   V o F. En RR el SO lanza una interrupción para desalojar al proceso en ejecución
   y selecciona al siguiente proceso en LISTO
   #+END_QUOTE
*** Respuesta Correcta
    Falso
*** Justificación Respuestas Incorrectas
    EL SO no lanza, sino que atiende la interrupción de clock
*** Observaciones
    No es el SO el que interrumpe la ejecución sino el timer (que es programado por el
    planificador antes de poner a ejecutar el proceso de usuario) lanzando una interrupción
    de fin de quantum. Luego el SO atiende dicha interrupción y el planificador
    selecciona a otro proceso para ejecutar.
** [#B] Pregunta (7)
   #+BEGIN_QUOTE
   V o F. Para un algoritmo de tipo "Feedback" no es suficiente saber que tiene dos
   colas de planificación y que ambas utilizan RR para poder implementar el algoritmo.
   #+END_QUOTE
*** Respuesta Correcta
    Verdadero
*** Justificación Respuestas Incorrectas
*** Observaciones
    Es necesario saber también:
    - a qué cola ingresan los procesos nuevos?
    - cuáles son las prioridades entre colas?
    - hay desalojo entre ellas?
    - cuál es el criterio para pasar de una cola de mayor prioridad?
    - se puede pasar de una cola de menor prioridad a una de mayor?
** [#A] Pregunta (8)
   #+BEGIN_QUOTE
   ¿Cuáles de los siguientes algoritmos podrían sufrir de inanición?
   
   1. FIFO <- Ojo..!
   2. SJF
   3. Por prioridades
   4. RR
   5. VRR
   6. HRRN
   7. Feedback
   #+END_QUOTE
*** Respuesta Correcta
   - (2) SJF
   - (3) Por prioridades
   - (7) Feedback (/porque depende de los algoritmos elegidos/)
*** Justificación Respuestas Incorrectas
    _Todos los de sin desalojo que priorizen, podria generar starvation_
*** Observaciones
    1. FIFO: respeta el orden de llegada, por lo que atenderá a todos en dicho orden
    2. RR: igual que FIFO, pero con límite de Q
    3. VRR: podría generar la impresión de generar inanición por la cola prioritaria.
       Sin embargo, lo que hay que recordar es que ese Q' tiende a 0, es decir,
       cuando finalmente consuma todo el Q inicial vuelve a la cola menos prioritaria.
    4. HRRN: fuera de que privilegia a los procesos de ráfagas cortas, al meter en la
       ecuación el tiempo de espera hace que los procesos largos no sufran de inanición
* Cuestionario (3)
** Pregunta (1)
   #+BEGIN_QUOTE
   V/F
   ¿En caso de utilizar jacketing sería lo mismo utilizar ULTs/KLTs?
   #+END_QUOTE
*** Respuesta Correcta
    F
*** Justificación Respuestas Incorrectas
*** Observaciones
    Ya que el SO sigue sin "ver" dichos ULTs no puede planificarlos (ej, asignarles un Q, o ejecutarlos en distintas CPUs)
    Recordar que lo único que soluciona jacketing es que el KLT/Proceso asociado a los ULTs no se bloquee y la biblioteca pueda planificar otro ULT en caso de tener alguno LISTo.
** Pregunta (2)
   #+BEGIN_QUOTE
   Indique cuáles de las siguientes afirmaciones son VERDADERAs sobre planificación con biblioteca de ULTs
   
   1. Si hay varios KLTs con ULTs todos los KLTs deben usar la misma biblioteca de ULTs
   2. Si decidimos usar ULTs es igual de útil usar directo syscalls (ej write) que usar los wrappers de las sycalls provistas por la biblioteca
   3. Cuando un ULT necesita realizar una IO se lo pide al SO con una syscall. En este caso, el SO puede diferenciar cuál ULT lo está pidiendo.
   4. Todas son correctas
   5. Ninguna es correcta
   #+END_QUOTE
*** Respuesta Correcta
   - Ninguna es correcta
*** Justificación Respuestas Incorrectas
*** Observaciones
    Son todas falsas:
    - Cada KLT puede usar una biblioteca distinta, y por ende tener distintos criterios de planificación
    - Si llamamos directo a syscalls bloqueantes desde el código de nuestros ULTs no permitimos que la biblioteca replanifique cuando sea necesario para el algoritmo usado
    - El SO no "ve" ni sabe de la existencia de los ULTs, cuando le llega el pedido de una sycall, sólamente sabe que vino de una entidad de planificación que conoce, como un KLT o un proceso
** Pregunta (3)
   #+BEGIN_QUOTE
   Un proceso posee 3 KLTs y cada uno 3 ULTs asociados.
   Si un ULT necesita hacer una syscall bloqueante (ej read) ...
   ¿cuáles de las siguientes afirmaciones PODRÍAN ser ciertas?

   1. Por default todo el KLT se bloquea
   2. Por default todo el KLT y el proceso asociado se bloquean
   3. Podría no bloquearse todo el KLT
   4. Al finalizar la operación bloqueante y ser seleccionados por el planificador del SO vuelve a ejecutar el mismo ULT
   5. Al finalizar la operación bloqueante y ser seleccionados por el planificador del SO ejecuta el ULT que seleccione la biblioteca de ULTs
   #+END_QUOTE
*** Respuesta Correcta
    Todas
*** Justificación Respuestas Incorrectas
*** Observaciones
    El SO por default "ve" que la syscall llega del KLT asociado, por lo que lo bloquea. Por otro lado, en caso de utilizar jacketing, podría ejecutar otro ULT del mismo KLT sin bloquearse.
    Luego de finalizar la operación bloqueante:
    - Si se realizó la syscall directo -> va a continuar con el ULT que hizo la llamada
    - Si se realizó la syscall desde una función wrapper de la biblioteca -> la bilioteca podrá seleccionar al siguiente ULT a ejecutar (que igualmente podría ser el que originó la llamada)
    En caso de que justo el último KLT de un proceso se bloquee, quedaría todo el proceso en estado bloquado
** Pregunta (4)
   #+BEGIN_QUOTE
   V o F.
   En caso de elegir usar ULTs con jacketing vs KLTs, la única desventaja sería no poder aprovechar el multiprocesamiento.
   #+END_QUOTE
*** Respuesta Correcta
    Falso
*** Justificación Respuestas Incorrectas
*** Observaciones
    Otra desventaja es que en caso de tener un algoritmo con quantum, todos los ULTs deberán compartirlo vs en un esquema con KLTs cada uno recibiría 1 Q
** [TODO] Pregunta (5)
   #+BEGIN_QUOTE
   Considere el siguiente sistema en el que en un momento (está empezada la ejecución) tenemos el siguiente estado. Sabiendo que el SO planifica con SJF, que el estimado anterior de KAA fue 3 y que los 3 ULTs ya estaban ready. Responda cuáles de las siguientes afirmaciones son verdaderas. (aclaración alpha = 0,5)

    1. El próximo estimado de KAA será 4
    2. KAA nunca llega a bloquearse
    3. KAA utiliza una biblioteca de ULTs con jacketing
    4. La biblioteca de ULTs de KAA utiliza SJF
   #+END_QUOTE

   [[./img/cuestionario-plani-1.png]]
*** Respuesta Correcta
    - El próximo estimado de KAA será 4
    - KAA utiliza una biblioteca de ULTs con jacketing
*** Justificación Respuestas Incorrectas
*** Observaciones
    - Como el estimado anterior fue de 3, y ejecutó 5 unidades hasta bloquearse (entre todos los ults) su próximo estimado es de (3+5)/2
    - Hay un momento en el que todos los ULTs están bloqueados, por lo que el KLT se bloquea (la biblioteca no tiene nada más para ejecutar)
    - La biblioteca de KAA usa jacketing ya que vemos que hay un ULT ejecutando mientras otro realiza una IO
    - No podemos afirmar que la biblioteca de KAA utilice SJF ya que depende un poco de los estimados, bien podría ser FIFO

* Cuestionario (4)
** Los planificadores de largo y mediano plazo pueden afectar el orden de los procesos
   a. En la lista de procesos suspendidos.
   b. En lista de procesos listos para ejecutar.
   c. En la lista de procesos nuevos. 
*** Respuesta elegida
   c. En la lista de procesos nuevos. 
*** Respuesta correcta
   b. En lista de procesos listos para ejecutar.
*** Observaciones
    - El *planificador de largo plazo*, al momento de admitir un proceso nuevo, 
      puede afectar el orden de los procesos de Listos.
    - El *planificador de medio plazo*, puede afectar el orden de los procesos listos 
      cuando un proceso es pasado de disco a memoria.
** El planificador de corto plazo es invocado cuando
   a. Se realiza una llamada al sistema o una interrupción. 
   b. Se realiza una llamada al sistema y una interrupción.
   c. Ninguna de las anteriores.
*** Respuesta elegida
   a. Se realiza una llamada al sistema o una interrupción. 
*** Respuesta elegida
   a. Se realiza una llamada al sistema o una interrupción. 
*** Respuesta correcta
   a. Se realiza una llamada al sistema o una interrupción. 
*** Observaciones
    - Cuando un proceso realiza una *llamada al sistema*, podría cambiar su estado a *Bloqueado*.
    - Una *interrupción* puede provocar que un proceso se desbloquee y
      quede en *estado Listo* o que cambie de estado *Ejecutando a Listo*.
 
    <<DUDA 1>>: Ejemplo de Ejecutando a Listo?
** El Response Time es un criterio de planificación
   a. Ninguna de las anteriores.
   b. Orientado al sistema.
   c. Orientado al usuario. 
*** Respuesta elegida
   c. Orientado al usuario. 
*** Respuesta correcta
   c. Orientado al usuario. 
*** Observaciones
    Es el tiempo que el usuario espera desde que realiza una operación hasta recibe alguna respuesta del sistema.

** Al utilizar el algoritmo Round Robin, el quantum
   a. Ninguna de las anteriores. 
   b. Debería ser lo más grande posible.
   c. Debería ser lo más chico posible.
*** Respuesta elegida
   a. Ninguna de las anteriores. 
*** Respuesta correcta
   a. Ninguna de las anteriores. 
*** Observaciones
    - Si el *quantum es muy grande*, el algoritmo degenera en FIFO.
    - Si el *quantum es muy chico*, el algoritmo se vuelve más justo porque los procesos avanzan 
    de manera más pareja, pero genera mucho *Overhead* por todas las intervenciones necesarias del sistema operativo.
** La interrupción de Clock permite
   a. Que el procesador realice un cambio de proceso. 
   b. Ninguna de las anteriores.
   c. Que un proceso pueda realizar una llamada al sistema.
*** Respuesta elegida
   a. Que el procesador realice un cambio de proceso. 
*** Respuesta correcta
   b. Ninguna de las anteriores.
*** Observaciones
    La *interrupción de Clock* permite que el SO, tome el control del procesador 
    para que realice alguna tarea.
    Esa tarea puede ser realizar un cambio de proceso, o no.
    El procesador no realiza cambios de proceso.
** [TODO] Para algoritmos que usan la próxima ráfaga de CPU, como el SJF
   a. Generalmente solo se pueden implementar con un estimador de ráfagas.
   b. Generalmente se pueden implementar «de una», porque los procesos proveen esa información.
   c. Ninguna de las anteriores. 
*** Respuesta elegida
   c. Ninguna de las anteriores. 
*** Respuesta correcta
   a. Generalmente solo se pueden implementar con un estimador de ráfagas.
*** Observaciones
    El SO no conoce de antemano cuál será el tiempo de cada ráfaga.
    Por lo tanto es necesario estimarla.
** [#A] Starvation (inanición) es una problemática que
   a. Ocurrirá siempre que se utilizen algoritmos como SJF.
   b. Ninguna de las anteriores. 
   c. Podría nunca ocurrir, independientemente del algoritmo utilizado.
*** Respuesta elegida
   b. Ninguna de las anteriores. 
*** Respuesta correcta
   c. Podría nunca ocurrir, independientemente del algoritmo utilizado.
*** Observaciones
    Algunos algoritmos no sufren inanición. Otros algoritmos PODRÍAN sufrirla, 
    pero tienen que darse ciertas condiciones. 
    Por ejemplo SJF puede sufrir inanición, pero si todas las ráfagas de 
    los procesos son iguales, entonces no habrá inanición.
** En un algoritmo multinivel realimentado (Feedback Multinivel)
   a. La prioridad de los procesos es estática.
   b. Ninguna de las anteriores.
   c. La prioridad de los procesos es dinámica. 
*** Respuesta elegida
   c. La prioridad de los procesos es dinámica. 
*** Respuesta correcta
   c. La prioridad de los procesos es dinámica. 
*** Observaciones
    Cuando se utiliza "feedback multinivel", durante el ciclo de vida de un proceso, 
    este puede moverse entre las diferentes listas de "ready" que pueden tener 
    diferentes prioridades entre sí. 
    El sistema operativo seleccionará los procesos de la lista más prioritaria. 
    En caso que esta última lista este vacía, se continúa por la siguiente en orden de prioridad.
** [#B] En un SO con RR y procesos CPU-Bound y I/O-Bound se verían perjudicados
   a. Ninguna de las anteriores.
   b. Los procesos CPU Bound.
   c. Los procesos I/O Bound. 
*** Respuesta elegida
   c. Los procesos I/O Bound. 
*** Respuesta correcta
   c. Los procesos I/O Bound. 
*** Observaciones
    Los I/O Bound (o Limitados por E/S) serán perjudicados porque sus ráfagas de CPU son cortas.
    Por lo tanto, no suelen aprovechar todo el quantum asignado.
    Además estarán compitiendo por el uso del procesador, con otros procesos que podrían estar 
    aprovechando más tiempo el procesador. Para atenuar este problema está el algoritmo Virtual Round Robin.
* Cuestionario (5)
** Pregunta 1
   En que momento se atienden las interrupciones?
   (Suponiendo que NO están deshabilitadas)
   
   *Respuesta:*
   Al finalizar de atender la instrucción en curso
** Pregunta 2
   Cual seria la info basica que siempre se debe guardar
   antes de atender una interrupción?

   *Respuesta:*
   El (PC, Program Counter) porque guarda la dirección de memoria
   de la siguiente instrucción a ejecutar, para continuar el 
   ciclo de la instrucción

   y el (PSW, Program Status Word) porque guarda el bit que
   representa el modo (usuario/kernel)
** Pregunta 3
   CLI es una instrucción que lo que hace es deshabilitar las
   interrupciones. ¿QUe debería ocurrir si se ejecuta la misma?

   *Respuesta:*
   Depende de en que momento se ejecute,

   Si estaba en Modo Usuario, _lanzaría una excepción_
   Si estaba en Modo Kernel, cambiaria el bit del IF (INterrupt Flag)
   en el PSW e _iba a poder ejecutar_
** [TODO] Pregunta 4
   Cual de las sig. son interupciones sincrónicas?
   1. Acceder a una dirección de memoria NO permitida
   2. FIN de quantum
   3. FIN de entrada salida
   4. División por cero
   5. Error de un dispositivo
   6. Llamado explícito a lanzar una interrupción

   *Observación:*
   - Una ~interrupción sincrónica~ es el resultado de la ejecución de la CPU
     en ese momento

   *Respuesta:*
   la 1) 4) 6) son Sincrónicas
   Las otras 2) 3) 5) son asíncronas
** Pregunta 5
   Cuales son las ventajas de los microkernels?
   
   *Respuesta:*
   - Robustez, flexibilidad, tolerencia a fallas
   - Facilidad de intercambiar un módulo con otro
  
   *Respuestas INCORRECTAS:*
   - Es el más utilizado
   - Buena comunicación entre módulos
** Pregunta 6
   Cual seria la forma correcta de acceder a un dispositivo desde un
   proceso de usuario? (Ej. leer de disco)

   *Respuesta:*
   - Llamar a una función wraper que luego llama a una syscall
   - Llamar a la syscall por el SO
   
   *Respuestas INCORRECTAS:*
   1. Llamar a una instrucció para realizar la IO
   2. Lanzar una interrupción para lograr un modo kernel, y luego
     la instrucción requerida
** Pregunta 7
   CUales de las siguientes afirmaciones son correctas?
   1. SI ocurre un cambio de proceso => va ocurrir mas de un cambio de modo
   2. Si ocurre un cambio de contexto => va a ocurir un cambio de proceso
   3. SI ocurre un cambio de modo => va a ocurrir un cabio de contexto

   *Respuesta:*
   La 1) 

   La 3)

   *Respuestas INCORRECTAS:*
   la 2) porque puede haber una ~interrupcion~ y sigue ejecutando el mismo
   ó también si hubo una ~syscall~
** Pregunta 8
   Cuales de las sig. afirmaciones sobre procesos son FALSAS?
   1. Al finalizar se liberan los recursos que tenia asignados
   2. Por default comparten memoria con su proceso padre parapoder comunicarse
   3. Posee un PCB que SIEMPRE debe esta en la RAM
   4. Son menos estables y seguros que los hilos KLTs
   5. Es la minima unidad de planificación para el SO
   6. Pueden comunicarse con otros procesos con otros procesos con paso de mensajes

   *Respuesta:*
   La 2) solo comparten 

   la 4)
   
   la 5) suponiendo que el sistema soporte hilos
   
   la 6) 

   *Respuestas INCORRECTAS:*
   La 1) 

   la 3) porque si NO estuviera en RAM, y el proceso estuviese suspendido
   osea está en disco, NO podriamos despertarlo
** Pregunta 9
   Tanto los procesos como los KLTs y ULTs son creados a través de ~syscalls~
   brindadas por el SO. Es V/F?

   *Respuesta:*
   Es FALSO,
   poque las ULTs se crean a partir de una *biblioteca de usuario*
   y el SO no las conoce
** Pregunta 10
   La creación y switcheo entre ULTs del mismo KLT/proceso es más liviano
   que la gestión de KLTs. Es V/F?

   *Respuesta:*
   Es VERDADERO, 
   porque el switcheo no hay *cambio de contexto* ni *cambio de modo*

* Cuestionario (6)
** Pregunta 1
   Cual de los sig. podrian ser sintomas de que esta ocurriendo
   una *Condición de carrera*?
   a) Los procesos estan bloqueados y no pueden ejecutar
   b) Los procesos siguen ejecutando peo no pueden finalizar
   c) Los procesos pueden ejecutar pero tienen resultados
      erráticos (cambia según el orden de ejecución)
*** Respuesta correcta
   c) Los procesos pueden ejecutar pero tienen resultados
      erráticos (cambia según el orden de ejecución)
*** Observaciones
** Pregunta 2
   Que condiciones son necesarias para que exista una *condicion de carrera* ?
   
   a) dos o mas procesos/hilos accediendo al un mismo recurso comun
   b) dos o mas procesos/hilos accediendo a un recurso comun, ambos en modo lectura
   c) dos o mas procesos/hilos accediendo a un recurso comun, ambos en modo escritura
   d) dos o mas pocesos/hilos accediendo a un recurso comun en *forma concurrente*
*** Respuesta correcta
   a) dos o mas procesos/hilos accediendo al un mismo recurso comun
   d) dos o mas pocesos/hilos accediendo a un recurso comun en *forma concurrente*

   Para ambos casos es necesario *Sincronizar*
*** Respuestas INCORRECTAS
    la b) y c) estaría mal, se cumple con que uno esté en modo escritura
*** Observaciones
** Pregunta 3
   Cual de las sig. afirmacones son corectas sobre la *Región Crítica* ?

   a) Dentro de la misma se suele aprovechar paraacceder a varios recursos
      compartidos para ser más eficientes
   b) debe ser lo más chica posible
   c) la misma debe estar rodeada por unprotocolo de seccion de entrada/salida
   d) segun como este construida la seccion de entrada podria dejar entrar a uno
      o mas procesos a la región crítica
*** Respuesta correcta
   b) debe ser lo más chica posible
   c) la misma debe estar rodeada por unprotocolo de seccion de entrada/salida
*** Respuestas INCORRECTAS
    la a) estaría mal, porque se trata siempre de acceder a algo muy puntual
    como un solo recurso (ej. una variable), no a muchos recursos

    la d) estaría MAL, porque la idea es que cumpla con la *Mutua Exclusión*
    es decir solo un proceso por vez
*** Observaciones
** Pregunta 4
   Que condiciones deberia cumplir una buena solución a la *Condición de Carrera* ?
   
   a) permitir que un proceso pueda ingresar a la SC eventualmente,
      que tarde mas o menos pero que NO genere *Starvation* (inanición)
   b) Sin importar cuantas veces un proceso necesite ingresa a la SC, pueda hacerlo
      sin problemas
   c) No debe condicionar el ingreso a la SC a otros procesos que no estén en la 
      sección de entrada
   d) Garantizar que solo un poceso pueda ingresar a la vez en la SC
*** Respuesta correcta
    Todas..
    la a) hace referencia a la "espera limitada"
    la b) hace referencia a la "velocidad relativa" de los procesos
    la d) hace referencia a la *muta exclusión*
    al c) hace referencia al *progreso* (recorda el ejemplo de turnos, en el que uno
    quería acceder y no podia, y debia esperar al otro que quizas no hacia nada
    relacionado a la SC, y lo LIMITA a progresar)
*** Observaciones
** Pregunta 5
   CUales de las sig. son opciones para garantizar *mutua exclusión* ?
   a) solucion de peterson
   b) semaforo mutex
   c) test_and_set
   d) monitores
   e) deshabilitar interrupciones
*** Respuesta correcta
    todas..
*** Observaciones
    recordar que la c) de test_and_set es a nivel de hardware
** Pregunta 6
   V o F?
   *Swap and Exchange* y *deshabilitar interrupciones* son opciones validas
   para solucionar el problema de la *condicion de carrera*.
   Sin embargo la 2da opcion NO siempre es recomendada
*** Respuesta correcta
    Verdadero,
    porque el de *deshabilitar interrupciones* NO se recomienda para un sistema
    con multiprocesadores, sino para uno.
*** Observaciones
** Pregunta 7
   Cual de los sig. valores de inicialización de *semaforos* son correctos?

   a) 1
   b) 10
   c) -1
   d) 0
*** Respuesta correcta
   a) 1, 
   en el caso que usemos un *semáforo mutex* (para que uno de los proceso se active,
   y empiecen a alternarse entre los procesos)
   ó un *semáforo binario* que esté inicialmente habilitado


   b) 10
   en el caso de que usemos un *semaforo contador*,

   d) 0
   en el caso que esperemos alguna condición
*** Observaciones
** Pregunta 8
   V o F?
   Las funciones de acceso al *Mutex* pueden ser implementadas 
   *con bloqueo* y *sin bloqueo* (espera activa).
   Sin embargo, *con bloqueo* es la forma más recomendada para
   favorecer la performance.
*** Respuesta correcta
    Falso,
    Si se tratase de un sistema con un esquema de *monoprocesador*
    sería recomendado *con bloqueo*

    En la actualidad, NO se recomienda *con bloqueo*, 
    porque todos los sistemas son con *multiprocesadores*
    y no es eficiente en esos.
*** Observaciones
** [TODO] Pregunta 9
   Si en un momento miramos el estado de los semaforos, y vemos que uno
   tiene un valor -4. Que podriamos deducir?

   a) Los semaforos se estan usando con una implementacion con *espera activa*
   b) Los semaforos se estan usando con una implementacion *con bloqueo*
   c) Hay un error con ese semaforo
   d) Hay 4 pocesos en *estado bloqueado* en general en el sistema
   e) hay 4 procesos en *estado bloqueado* por ese semaforo
*** Respuesta correcta
   b) Los semaforos se estan usando con una implementacion *con bloqueo*
   e) hay 4 procesos en *estado bloqueado* por ese semaforo
*** Respuesta INCORRECTAS
    la a) porque con *espera activa* NUNCA tiene valores negativos
*** Observaciones
** Pregunta 10
   V ó F ?
   El problema de *inversión de prioridads* podria ocurrir siempre que
   en un sistema que utilice *mutex* sobre sus recursos?
*** Respuesta correcta
    Falso,
    recordar que las condiciones que generan este problema eran 
    1. estemos usando recursos con *mutua exclusión*
    2. tener *planificador* que elije el más prioritario
*** Observaciones
* Cuestionario (7)
** Pregunta 1
   Multiprocesamiento implica:
   a) Procesamiento Distribuido 
   b) NS/NC
   c) Ninguna de las anteriores
   d) Multiprogramación.
*** Respuesta elegida
   a) Procesamiento Distribuido 
*** Respuesta correcta
   d) Multiprogramación.
*** Observaciones
** Pregunta 2
   Si los procesos interactúan compartiendo recursos del sistema, entonces:

   a. Es necesario sincronizar su uso, porque el SO no lo hace. 
   b. No es necesario sincronizar su uso, porque el SO los administra
   c. Ninguna de las anteriores
   d. NS/NC
*** Respuesta elegida
   a. Es necesario sincronizar su uso, porque el SO no lo hace. 
*** Respuesta correcta
   a. Es necesario sincronizar su uso, porque el SO no lo hace. 
*** Observaciones
** Pregunta 3
   En el ejemplo de los incrementos de una misma variable entre dos 
   o más hilos visto en clase :

   a. Ninguna de las anteriores
   b. Puede haber problemas debido al uso de variables del stack (pila)
   c. El comportamiendo es indefinido porque siempre se corromperán datos internos 
   d. NS/NC
*** Respuesta elegida
   c. El comportamiendo es indefinido porque siempre se corromperán datos internos 
*** Respuesta correcta
   a. Ninguna de las anteriores
*** Observaciones
** [TODO] Pregunta 4
   En la mutua exclusión:

   a. Se pierde algo de la performance obtenida de la concurrencia
   b. Ninguna de las anteriores
   c. NS/NC
   d. Es obligatorio que dentro de la región crítica el proceso esté un tiempo reducido 

   <<DUDA 1>>: Porque estaria mal la d) ???
*** Respuesta elegida
   d. Es obligatorio que dentro de la región crítica el proceso esté un tiempo reducido 
*** Respuesta correcta
   a. Se pierde algo de la performance obtenida de la concurrencia
*** Observaciones
** Pregunta 5
   En las soluciones de software para garantizar mutua exclusión:

   Seleccione una:
   a. La performance es un factor clave que les juega en contra
   b. NS/NC
   c. Ninguna de las anteriores
   d. No existen algoritmos que garanticen la mutua exclusión en un 100% 

   <<DUDA 2>>: La d estaria mal porque en realidad, ninguno garantiza el tema
   de la *espera activa* (?
*** Respuesta elegida
   d. No existen algoritmos que garanticen la mutua exclusión en un 100% 
*** Respuesta correcta
   a. La performance es un factor clave que les juega en contra
*** Observaciones
** Pregunta 6
   En las soluciones de mutua exclusión por hardware:

   a. Ninguna de las anteriores
   b. Las instrucciones como «test and set» pueden ser igualmente interrumpidas 
   c. NS/NC
   d. La deshabilitación de las interrupciones es un mecanismo ineficiente pero seguro

   <<DUDA 3>>: NO pueden ser interrumpidas porque son a nivel hardware?
*** Respuesta elegida
   b. Las instrucciones como «test and set» pueden ser igualmente interrumpidas 
*** Respuesta correcta
   d. La deshabilitación de las interrupciones es un mecanismo ineficiente pero seguro
*** Observaciones
** Pregunta 7
   Al usar semáforos:

   a. Al llamar a signal(s), se despierta un proceso si el semáforo no quedó positivo
   b. Al llamar a signal(s), se despierta a un proceso si el semáforo quedó positivo
   c. Ninguna de las anteriores 
   d. NS/NC
*** Respuesta elegida
   c. Ninguna de las anteriores 
*** Respuesta correcta
   a. Al llamar a signal(s), se despierta un proceso si el semáforo no quedó positivo
*** Observaciones
** Pregunta 8
   La «atomicidad» de las funciones de manejo de semáforos se logra:

   a. Ninguna de las anteriores
   b. Usando otros semáforos
   c. NS/NC
   d. Mediante el hecho de que dichas funciones son instrucciones de procesador
   e. Mediante alguna solución de software o hardware 
*** Respuesta elegida
   e. Mediante alguna solución de software o hardware 
*** Respuesta correcta
   e. Mediante alguna solución de software o hardware 
*** Observaciones
** Pregunta 9
   En los monitores:

   a. Ninguna de las anteriores 
   b. Se pueden resolver problemas de coordinación, pero no de mutua exclusión
   c. Se pueden resolver problemas de mutua exclusión, pero no de coordinación
   d. NS/NC
*** Respuesta elegida
   a. Ninguna de las anteriores 
*** Respuesta correcta
   a. Ninguna de las anteriores 
*** Observaciones
