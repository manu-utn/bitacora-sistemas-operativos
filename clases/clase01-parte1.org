#+TITLE: Clase 01 - Repaso Hw

* conceptos al aire
** Sistema Operativo
*** Conceptos
   - Administrar los recursos
   - Ejecutar los programas
** Memoria Virtual 
** Proceso
*** Estados
    - Inactivo
    - En ejecución
*** Conceptos
    - Ocupan espacio
    - Archivos ejecutables almacenados
*** Ejecucion
    - Multitareas
**** ejecución en paralelo
     hacemos dos cosas al mismo tiempo
     (porque tenemos varios procesadores)
**** ejecución concurrente/simultaneo 

* Elementos Básicos
  - Procesador
  - Memoria
  - Módulo de E/S
* Sistema operativo
  - pueden NO funcionar en algunos procesadores (Ej. 32/64 bits)
  - representaría a la parte Software
* Procesador
** Registros
*** Tipos
    |-------------------+----------+-----------------------------------------------|
    |                   | Registro | Nombre                                        |
    |-------------------+----------+-----------------------------------------------|
    | De Uso Especifico | SP       | Stack Pointer                                 |
    | (fundamentales)   |          |                                               |
    |                   | PC       | Program Counter                               |
    |                   |          | - Indica próxima instrucción a ejecutar       |
    |                   |          | - Fundamental para los [[Cambio de Contexto]]     |
    |                   |          |                                               |
    |                   | PSW      | Program Status Word                           |
    |                   |          | - Indica en que [[file:clase01-parte2.org::*Modos de ejecución][modo de ejecución]] está la CPU |
    |                   |          | (Osea *modo kernel* ó *modo usuario*)         |
    |-------------------+----------+-----------------------------------------------|
    | De Control        | IR       | Instruction Register                          |
    |                   | MAR      | Memory Address Register                       |
    |                   | MBR      | Memory Buffer Register                        |
    |-------------------+----------+-----------------------------------------------|
    | De Uso General    | AX       | Accumulator                                   |
    |                   | CX       | Contador                                      |
    |                   |          |                                               |
    |-------------------+----------+-----------------------------------------------|
    | De Segmento       | CS       | Code Segment                                  |
    |                   | DS       | Data Segment                                  |
    |                   | SS       | Stack Segment                                 |
    |-------------------+----------+-----------------------------------------------|

    *Observación:*
    - EL PSW permite el proceso de *depurar código*
*** Clasificación
**** Registros visibles por el usuario
      - podemos ejecutar de forma directa
      - el usuario puede manipular/ejecutar
      - donde se guardan las variables
**** Registros de control y estado (PSW ?)
     - el estado se modifica cuando
       - hay algun error como una división por cero, ..
       - por cada instrucción que se ejecuta
     - el control.. (podria estar el program counter?)
** Instrucciones
*** Conceptos
   - Son las tareas que sabe hacer el *procesador*
     (Ej. operaciones ariméticas, ...)
*** Ciclo de Instrucción
    #+BEGIN_QUOTE
    Para ejecutar un archivo debe estar cargado en la memoria
    porque solo los que están en memoria se pueden ejecutar
    y son las instrucciones de los programas los que están en
    la memoria
    #+END_QUOTE

    Se realiza un *ciclo de instrucción* para ejecutar los programas
    instruccion por instrucción
**** Diagrama
**** Paso a paso
     1. FETCH (busca la siguiente instrucción)
        - El "program counter" es el que tiene la sig. 
        - El procesador va a buscar esa instrucción
     2. DECODE
        - se decodifica la instrucción
        - se traen los operandos (/algunas instrucciones no los tienen, Ej. NOP, CLI/)
     3. EXECUTE
        - cuando ya tenemos los operandos
     4. se repite el ciclo (vuelve al FETCH)
        - el [[Registro PC][Registro PC]] incrementa en 1
        - a menos que sea una opeación de salto (jz, jnz)
     5. WRITE
        - se escriben los resultados
     6. finaliza
        - cuando termina la instrucción
**** Observaciones
     Siempre que se ejecuta el FETCH, luego se EJECUTA la instrucción
     y luego se chequea si hay hubo una nueva [[Interrupciones][interrupción]]
**** Ejemplos
    #+BEGIN_EXAMPLE
    i = i +1

    1. FETCH: el procesador ejecuta el fetch
       - El PC busca la instrucción en el procesador
    2. EXECUTE: ejecuta la instrucción (le suma 1)
       - En el IR cargamos la instrucción
    3. finaliza
       - luego que le sume 1, y vea que incrementó
         sino repite el ciclo
    4. repite el ciclo de instrucción
       - vuelve a hacer el FETCH
    #+END_EXAMPLE
*** Instrucciones privilegiadas 
    - SOLO las puede ejecutar el sistema operativo
    - NO pueden ser modificados
*** Ejemplos
    #+BEGIN_EXAMPLE
    i = i +1;

    no es una instrucción,
    es una sentencia que tiene conjunto de instrucciones (que son 3)
    #+END_EXAMPLE

    a bajo nivel las instrucciones en x86 serían:
    
    #+BEGIN_EXAMPLE
    mov AC[100Ah]
    add AC,1
    mov [100Ah],AC
    #+END_EXAMPLE
** Interrupciones - Clasificación
*** Conceptos
   #+BEGIN_QUOTE
   - Para cortar la ejecución de la secuencia actual de instrucciones
   - son notificaciones de eventos dirigidas al *Procesador*
   #+END_QUOTE

   - son dirigidas al [[Procesador][procesador]] (Al DMA si lo tuviese)
   - para poder ejecutar varios programas (en forma *concurrente*
     en intervalos de tiempos, no confundir con ejecución en paralelo/simultaneo)
   - el SO es el que interrumpe
   - las notificaciones pueden ser externas/internas (???)
*** De hardware (externas al procesador)
    - cuando son externas al procesador
   
    Ej. Una placa de red, una impresora, un disco...

    #+BEGIN_EXAMPLE
    Por ejemplo, recibo información en la placa de red,
    pero la placa de red no sabe que hacer con esa información,
    entonces se da un aviso al Procesador que la placa de red
    terminó de recibir la información.
    Entonces se produce una interrupción, y el SO hace 
    lo que tenga que hacer
    #+END_EXAMPLE
*** De software (internas al procesador)
    - consecuencia de algo que se está ejecutando (instrucciones)
    - cuando se generan, deben ser atendidas por el SO

    #+BEGIN_EXAMPLE
    Puede pasar con una división por cero,
    donde el programa se deja de ejecutar por el error,
    entonces se ejecuta el SO, quien maneja la interrupción)
    #+END_EXAMPLE
*** Enmascarables
    - el SO no necesita atenderlas de forma inmediata
*** No enmascarables
    - tienen más prioridad (para el hardware vital)
    - el SO se deben atender de forma inmediata, 
      deteniendo el *ciclo de ejecución* que estaba realizando
    - para problemas graves
    - el dispositivo que tiene el problema, es 
      quien tiene que mandar la interrupción 
    
    *Observación:*
    por más que el *bit* de habilitación esté deshabilitado, se van a atender igual
*** De E/S
    - cuando alguno de los dispositivos termina de realizar una operación
      (Ej. impresora de imprimir, placa de red de recibir info, ...)
    - notificacion de un evento al procesador
      (Para finalizar la ejecución de ese proceso, y que el SO haga
       algo con el)
*** fallas de HW
*** Clock
    - es como un temporizador que se ejecuta cada x tiempo
    - para disparar una interrupción en un tiempo determinado
    - por lo general para ejecutar programas
*** Habilitacion
    - Sólo las [[Enmascarables][enmascarables]] se pueden habilitar/deshabilitar
    - Las [[No Enmascarables][NO enmascarables]] se atienden estén o no habilitadas,
      porque se tienen que atender SI O SI
*** sincronas VS asincronas
**** Sincrona
     - es resultado que el CPU la está ejecutando en ese momento
       (/Ej. una división por cero/)
*** excepciones Vs traps
**** traps
     para manejar el código (depurar)
** [TODO] Interrupciones - Procesamiento
   #+BEGIN_COMMENT
   Detallar un poco más, con el vide de la clase
   #+END_COMMENT

*** A nivel hardware
    1. el dispositivo o HW -> genera interrupcion
    2. el CPU completa la ejecución de la *instrucción*
    3. el CPU identifica la fuente y lo notifica
    4. el CPU coloca el PC y el PSW en la pila de sistema
    5. el CPU carga el nuevo PC en función de la interrupcion

    Observaciones
    - En el PC se guarda la sig. instrucción
    - PIC: programmable interrupt controller
    - Interrupcón por HW -> IRQ  -> PIC
*** A nivel Software
    Continúa el último paso (5) del de HW

    1. La rutina guarda el resto de la info del estado de la CPU (en los registros)
    2. se procesa la *interrupcion*
    3. se restaura la info del estado de la CPU
    4. se restaura el anterior PC y PSW

    - Entre el paso (5) de HW y (1) de SW se le da el control al *Interrupt Handler*
*** [TODO] Interrupciones secuenciales
*** [TODO] Interrupciones anidadas
*** [TODO] Interrupciones secuenciales Vs anidadas
** Interrupt Handler
*** conceptos
    - modulo que se encarga de manejar las interrupciones
    - lo maneja el *Sistema Operativo*, él se encarga de estas tareas
    - lo controla de forma automática el SO, y toma el control
    - los programas de usuario no se dan cuenta que fueron interrumpidos
*** procesamiento de interruciones
    Tareas que realiza el =HW=
     1. Se genera una interrupcion (por algún dispositivo)
     2. finaliza la instrucción actual
     3. determina que hay una interrupción
     4. se guarda ~(PC)~ y ~(PSW)~ del programa
     5. se carga en ~(PC)~ la direccion del manejador de interrupcioes

     Luego las sig. tareas las realiza el =Sistema operativo=
     1. se guarda la información (del procesador)
        el program counter ~(PC)~ el ~(PSW)~
     2. procesa la interrupción
     3. restaura información del procesador guardada
        "carga todo de nuevo, el ~(PC)~ para saber que programa ejecutar"
     4. restaura ~PC~ y ~PSW~
*** multiples interrupciones
    cuando se tiene que ejecutar multiples 
    - en orden secuencial
    - en orden por prioridad
* Memoria
** Conceptos
  - Se almacenan los programas a ejecutar
  - Se almacenan datos (para que funcionen los programas)
** Jerarquía de memoria
  #+BEGIN_QUOTE
   Cuandos suspendemos la máquina, se guarda energia en la *memoria*
   por tanto sigue guardando en *volatil*

   Cuando hinbernamos la máquina, lo que está en la *caché* y en la *memoria*
   se guarda en no volatil
  #+END_QUOTE

   Si ordenamos por mayor velocidad y menor tamaño,
   - a mayor tamaño menor costo (en bit) y menor velocidad
   - mientras mas rapido, mas chiquito, y mas velocidad

   |            <c>             |
   |----------------------------|
   |      Registros de CPU      |
   |----------------------------|
   |       Memoria Caché        |
   |----------------------------|
   |     Memoria Principal      |
   |           (RAM)            |
   |----------------------------|
   |     Memoria Secundaria     |
   | (Discos de almacenamiento) |
   |----------------------------|

** Volatil
   - toda la información se borra al apagar la compu
** No volatil
   - persiste la informacion, apesar de apagar la computadora
* Técnicas de E/S
** E/S programada
*** COnceptos
   - NO muy utilizada
   - el *procesador se queda esperando* que termine el dispositivo E/S
     antes de continuar otra tarea
   - la realiza el procesador y se comunica con el controlador de disco
*** Proceso
  1. dispara operacion de lectura al modulo IO
  2. Leer estado del modulo de io
  3. Estado del controlador?
     - no preparado => vuelve a leer (2)
     - error
  4. preparado
     1. leer una palabra
     2. escribir palabra en memoria
     3. bloque final?
        + NO => vuelve a dipsarar lectura (1)
        + SI => Sig. instrucción
*** Ventaja
    - Rapido para transferencia
    - evita *overhead*
*** Desventajas (Problema)
    - MAL uso del CPU (/porque chequea a cada rato/)
*** Solución - Interrupciones - Interrup Handler
    - Se puede utilizar *interrupciones* para no estar chequeando
    - Engloba a los pasos (2) (3) (4)

    Ventajas:
    - SE evita el chequeo continuo
    Desventajas:
    - 
** E/S por interrupciones
   - Mejor que la anterior ([[E/S programada][E/S programada]])
   - el *procesador espera una interrupcion* pero mientras 
     puede realizar otras tareas
   - la realiza el procesador
** [#A] (DMA) Acceso directo a memoria
*** COnceptos
   - La más utilizada
   - Mejor que la anterior ([[E/S por interrupciones]])
   - es también por interrupciones
   - el *procesador* (CPU) le ordena al *DMA* que haga una operación de E/S
     y este le avisa al *procesador* (CPU) cuando termina y está cargada en memoria (RAM)
   - el *DMA* es otro dispositivo (otro procesador, con operaciones 
     más básicas, que NO son ejecutar el instrucciones)
*** Proceso
    1. dispara op de lectura al controlador de DMA
    2. leer estado del modulo de DMA <- interrupcion
    3. siguiente instrucción
*** Ventajas
    - se libera la cpu (interviene solo al principio)
    - transferencis mas eficientes
*** Desventajas
    - requiere un HW especial
    - requiere mas tiempo inical
    - robo de ciclo de bus
* Mecanismos de IO - IO Programa
* Módulo de E/S
  - Donde conectamos los dispositivos (teclado, mouse, monitor, ..)
* BUS
  - Para conectar el procesador, memoria, modulo de E/S

