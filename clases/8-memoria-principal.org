#+TITLE: Clase 08 - Memoria Principal
#+STARTUP: inlineimages
* Conceptos
** Que contiene
  En la *memoria principal* RAM (física) encontramos
  - Las *instrucciones* que se ejecutan
  - Los *datos* sobre los que se operan
** Espacios 
   Se divide en dos espacios
   1. El *Kernel space* (reservada para el SO)
   2. El *User space* (reservada para los procesos de usuario)
** Ejecución
   #+BEGIN_QUOTE
   Todas las *instrucciones* que se ejecutan y los *datos* sobre los que se operan
   deben estar en la *memoria principal* (fisica)
   #+END_QUOTE
* Velocidad
** Conceptos
   A nivel velocidad, los registros son lo más rápido, y el disco el más lento
   
   (+ lento) DISCO -> RAM -> CACHE -> REGISTROS (+ rápido)
** Disco
   - Es lento (por ser mecánico)
   - La excepción a esta regla, es si es un *disco de estado sólido*
** Registros (CPU)
   - Es más rápido
** Memoria (RAM)
   - Es más rápido
** Cache
   - Para información reducida
   - Para agilizar los accesos
* Requerimientos
** Realocación
   - Decidir si queda en un _lugar fijo en memoria_ o no
   - Elegir _en que momento realocar_

   #+BEGIN_QUOTE
   Un ejemplo de que se podría mover o no, sería la *imagen del proceso*
   es decir STACK+HEAP+DATOS+CODIGO+PCB
   #+END_QUOTE
** Protección
   - Es el *SO* quien proteje las secciones de memoria de los *procesos*
   - Un *proceso* NO puede acceder a un *espacio de memoria de direcciones* de otro sin permiso
** Compartir memoria
   - 
** Organización Lógica
   -_Como acceden_ los procesos a memoria
** Organización Física
   - _Como se almacena_ la memoria
* Reasignación de direcciones
** Conceptos
   1. *Programa -> Compilador*
      - En el código fuente
      - Las direcciones de memoria que elegimos son *simbólicas* (no son reales)
   2. *Compilador -> Loader*
      - Al momento de compilar se empiezan a definir las zonas de memoria
      - Se definen las *direcciones relativas* (reubicables/lógicas/virtuales)
      - Se pueden reubicar las direcciones
   3. *Loader -> Memoria Principal*
      - Se definen las *direcciones absolutas* (fisicas, direcciones que la memoria entiende)
                
   #+BEGIN_COMMENT
   Las direcciones absolutas de memoria se deben definir recien _en el momento de ejecución_
   porque...

   Se podrían definir las *direcciones absolutas* (PERO NO ES BUENO, porque...)
   #+END_COMMENT
** Tiempos
   La _reasignación de instrucciones y datos_ se puede realizar en 3 momentos:
   1. Tiempo de compilación
   2. Tiempo de carga
   3. Tiempo de ejecución

   *Nota:* en esos momentos se pueden definir las direcciones
** Diagrama
  #+BEGIN_SRC plantuml :exports results :file img/reasignacion-direcciones.png
    @startuml
    [programa] -> (compilador) : direcciones\n simbolicas
    (compilador) -> (loader) : direcciones\n reubicables
    (loader) -> [Memoria Principal] : direcciones\n absolutas
    @enduml
  #+END_SRC

  #+RESULTS:
  [[file:img/reasignacion-direcciones.png]]
* Traducción de direcciones
** Conceptos
   - La traducción de direcciones comienza durante *tiempo de ejecución* (/esto genera OVERHEAD/)
   - La definición de las direcciones es en *tiempo de ejecución*
   
   |-----------------------+---------------------------------------|
   | Momento               | Comparación Dirección Lógica y Fisica |
   |-----------------------+---------------------------------------|
   | Tiempo de compilación | Dirección Lógica == Dirección Física  |
   |                       |                                       |
   | Tiempo de carga       | Dirección Lógica == Dirección Física  |
   |                       |                                       |
   | Tiempo de ejecución   | Dirección Lógica != Dirección Física  |
   |-----------------------+---------------------------------------|
** Direcciones Lógicas (DL)
   - Cuando definimos las direcciones en tiempo de *compilación* ó *carga*
** Direcciones Físicas (DF)
   - Son las dirección válidas, que entiende la RAM
   - Se deben definir en *tiempo de ejecución*

   #+BEGIN_QUOTE
   Es más eficiente si las definimos en tiempo de compilación/carga porque
   es más directo, no necesitaria una traducción pero... HABRIA PROBLEMAS..
   #+END_QUOTE
** Unidad de Manejo de Memoria (MMU)
   - Es a nivel de hardware
   - Se encarga de la _traducción de direcciones_
   - Cuando la *CPU* le pase las direcciones a la *memoria principal*
   - Es el nexo entre la CPU y la Memoria Principal
** Componentes Involucrados
   + CPU
   + MMU (Unidad de Manejo de Memoria)
   + Memoria Principal
** Diagrama
  #+BEGIN_SRC plantuml :exports results :file img/traduccion-direcciones.png
    @startuml
    (CPU) -> (MMU) : Direcciones\n Logicas (DL)

    (MMU) -> [Memoria Principal] : Direcciones\n Fisicas (DF)
    @enduml
  #+END_SRC

  #+RESULTS:
  [[file:img/traduccion-direcciones.png]]
* Particiones Fijas/Dinámicas - Asignación Contigua
** Conceptos
  - Se particiona la (MP) *Memoria Principal* en *Particiones Contiguas*
  - Toda la *Imagen* (stack, heap, datos, codigo, pcb) de un proceso está en una *Partición*
  - Necesitamos guardar de cada partición, la *Base* y el *Limite*
    - En los PCBs (de los procesos activos en esa partición, para saber en que parte de la MP se encuentran)
    - En los registros (del CPU)

  *Observaciones:*
  - En el PCB siempre deberiamos guardar esa información en el caso de *swapping*
    (cuando se pasa información del Proceso de Memoria a Disco)
  - Se pasan a los Registros del CPU para trabajar más rápido, porque es el que se
    comunica con la RAM (a través del MMU)
 
  #+BEGIN_QUOTE
  Cuando un proceso pide acceder a una *dirección de memoria*, el CPU se comunica con la RAM 
  a través del MMU (/que es quien traduce las direcciones, para que lo entienda la RAM/)

  1. Validamos si ~DL < Limite~
     1. Primero chequeamos si la *dirección lógica de memoria* (DL) que pide el proceso es válida
     2. Evaluamos si la dirección es menor a la *longitud* (limite) de la partición (/eso indica el tamaño/).
  2. ~DF = Base + DL~ (nos desplazamos en la *dirección física* (DF) como si le sumaramos un *offset* a la posición actual)
     1. Si la *dirección lógica* es válida => calculamos la *dirección fisica* (DF)
        sumandole a la *dirección lógica* la *base* de la partición
  #+END_QUOTE

  #+BEGIN_QUOTE
  La posición de la *dirección lógica* (DL) dentro de la partición podría ser cero, 
  pero.. la posición REAL en Memoria es la *dirección física* que se calcula con ~base + DL~
  #+END_QUOTE
** Base
   - Es la *dirección física* (real) en la *Memoria Principal* (MP)
   - Representa el principio de la partición
   - Desde donde nos desplazamos (con el límite ó longitud)

   #+BEGIN_qUOTE
   ~Base (dirección física) + Límite (offset) = Dirección lógica~

   no es DL+offset = DF?

   En el PCB de c/proceso se guardaría la *Base*
   #+END_QUOTE
** Límite/Longitud
   - Sirve como seguridad, para chequear si una dirección es válida (/la que asignamos a un proceso/)
   - Es el tamaño/longitud de esa partición
   - Nos desplaza
** Tabla comparativa
   |-----------------------+-------------------------|
   | Tipo de asignación    | Tipo de Fragmentación   |
   |-----------------------+-------------------------|
   | De tamaño variable => | *FRAGMENTACION EXTERNA* |
   |                       |                         |
   | De tamaño fijo =>     | *FRAGMENTACION INTERNA* |
   |-----------------------+-------------------------|
** Particiones Fijas (PF)
*** Conceptos
    - Se definen N _particiones de un tamaño fijo_ (no puede haber más de N procesos en simultaneo)
    - Esas N particiones fijas indican cuantos procesos pueden haber en memoria
      (que es el *nivel de multiprogramación* cant. de procesos en memoria ejecutando concurrentemente)
    - NO se necesita conocer la *base*, sólo con saber el número de partición es suficiente
      (por ser todas las particiones de tamaño fijo)
*** Desventajas
    - Limitamos la cantidad y tamaño de los procesos
    - Aparece el problema de la *fragmentación interna* (espacios libres, que no se usan)
    - Los *Procesos* NO pueden ser más grandes que las *Particiones Fijas*
*** Fragmentación Interna
    - Es espacio sobrante que no usa el proceso asignado a esa partición
    - Es lo que sobra a una partición de memoria
      (Ej. si una partición es de 100, tiene un proceso que ocupa 80, esos 20 que sobran es la fragmentación interna)
** Particiones Dinámicas (PD)
*** Ventajas
    - El tamaño de las particiones se ajusta al tamaño del proceso (se define en el *momento de carga*)
    - NO limita la cant. de procesos en memoria (que si sucede en las particiones fijas)
    - NO hay *fragmentación interna* (porque cada proceso tiene espacio que necesitaba, al menos en ese instante de tiempo)
*** Desventajas
    - Aparece el problema de la *fragmentación externa*
    - Es más complejo de manejar 

    #+BEGIN_QUOTE
    Es más complejo de administar porque a medida que finalizan lo procesos,
    quedan esas particiones contiguas como huecos entre particiones donde hay
    otros procesos en ejecución
    #+END_QUOTE
*** Fragmentación Externa
    - Cuando NO hay suficiente *memoria contigua* (sucede cuando se finalizan procesos)
    - Es externa, porque no es dentro de cada partición
    - Quedan particiones libres, son huecos entre particiones que tienen procesos en ejecución
    - Impide que ingresen nuevos procesos, no podemos dividir al proceso que quiere ingresar
      entre las distintos huecos (zonas libres) que quedan entre las particiones, debe estar en una *zona CONTIGUA*

    #+BEGIN_QUOTE
    Es posible que si chequeamos la cantidad de memoria disponible para asignar a procesos,
    nos indique que tenemos suficiente.

    Pero en realidad no podríamos hacer esa asignación, porque hay fragmentación externa,
    *NO hay suficiente memoria contigua*. Porque entre las zonas libres hay particiones con *procesos activos*
    #+END_QUOTE
*** Compactación
**** Ventajas
    - Soluciona el problema de la *fragmentación externa* (huecos entre particiones que tienen procesos activos)
    - Reorganiza las particiones
      - agrupando aquellas que tienen procesos activos (en ejecución)
      - *consolida* las particiones libres (los huecos, formados por procesos que finalizaron) en una partición más grande
    - Cuando realizar? Cuando aparezca el problema de la *fragmentación externa*

    *Observación:*
    Consolidar significa unir/agrupar, a que dos o más particiones se junten en una.
**** Desventajas
    - Es una solución costosa, porque debe mover los procesos en memoria
    - Si el tamaño de los procesos crecen, se debe volver a reasignar la dirección 
      (porque delante tiene otra partición, y al crecer pisaría esa otra partición...)

    #+BEGIN_QUOTE
     Al agrupar las particiones para que otro proceso pueda acceder a memoria,
     implica que estas particiones queden contiguas (una al lado de la otra).

     Pero los *procesos activos* (en ejecución) que están dentro de esas particiones,
     podrían tener el problema de que no tienen espacio suficiente de la partición para crecer,
     se ven limitados al tamaño de la partición donde están.
     Además no podrían crecer, porque al lado de esa partición existe otra partición contigua
     que también tiene *procesos activos*.
     
     Por tanto se debe volver a reasignar una dirección a ese proceso que quiere crecer,
     ya que la dirección de memoria asignada no lo permite.
    #+END_QUOTE
*** Estrategias de asignación
**** Conceptos
     Existen 3 estrategias para saber en _que partición asignar_
     1. Primer ajuste
     2. Siguiente ajuste
     3. Mejor ajuste
**** Primer ajuste
     - Elije el primer hueco (partición libre) que encuentre
     - Es el más rápido
**** Siguiente ajuste
     - Elije el siguiente hueco (partición libre) a la última asignación
      (suponiendo que guardamos la ultima referencia en un puntero, porque... los punteros apuntan a direcciones en memoria)
**** Mejor ajuste
     - Busca el hueco más pequeño (partición libre más chica) que se ajuste al tamaño del proceso
     - Tiene mayor *overhead* porque tiene que analizar cada partición
**** [WAITING] Peor ajuste
     - Elije el hueco más grande (partición libre más grande) que encuentre (quedando espacio libre)
     - Tiene mayor *overhead* porque tiene que analizar cada partición
     - Puede llegar a reducir la cant. de *compactaciones*
     - Puede generar *fragmentación externa*

     #+BEGIN_QUOTE
     Puede generar *fragmentación externa* cuando finalice el proceso que contiene,
     quedando huecos (particiones libres) entre particiones que tienen procesos en ejecución.
     
     Que luego se podrá asignar a otro proceso, reduciendo la cant. de *compactaciones*
     #+END_QUOTE
* Paginación (Simple)
** Conceptos
   - La *Imagen* (stack, heap, datos, codigo, pcb) de un *Proceso* se guarda en varias *Particiones*
   - Se dividen a los *Procesos* en *Páginas*
   - Se divide a la *Memoria Principal* (MP) en *Marcos* (ó frames)
   - Las Páginas y Marcos son de *tamaño fijo* (genera fragmentación interna, aunque es mínima)
** Ventajas
   - Soluciona el problema de *Fragmentación Externa*
     - Impedía cargar nuevos procesos, porque quedaban huecos entre las particiones (donde la única solución era la *Compactación*)
     - No se podia cargar nuevos procesos porque *las particiones libres debían ser contiguas*
       y no se podia repartir el proceso entre esos huecos (particiones libres)

   #+BEGIN_QUOTE
   Soluciona el problema de *Fragmentación Externa* porque
   la Memoria Principal (MP) se divide en *Marcos* (espacios de memoria)

   y esos *Marcos* pueden ser asignados a cualquier *Página* (parte de un proceso)
   porque ambos son del mismo tamaño
   #+END_QUOTE
** Desventajas
   - Puede tener una mínima *Fragmentación Interna* (por usar tamaños fijos) en la última *Página* (por el pcb)
** Página
   - *El SO divide a los Procesos en Páginas* y luego se cargan en memoria
   - Se cargan en Memoria (en marcos de memoria)
** Marco
   - Representan el tamaño de página (se ve distribuido en distintas zonas de la memoria principal)
   - Almacenan páginas de un proceso particular
** Tabla de Páginas (TP)
*** Conceptos
    - Se tiene una *Tabla de Páginas* por cada *Proceso*, y puede que no utilice todas las *Páginas*
    - Es una *estructura en RAM*, donde se almacenan las páginas
    - Para acceder a una dirección de memoria, se debe recurrir a esta tabla
*** Almacenamiento
    Se guarda una referencia de la página (parte de un proceso) a la *Tabla de Páginas*
    - En el *PCB* del proceso
    - En los *Registros* (del CPU) en el _momento de ejecución_ (para el momento de traducción)
  
    #+BEGIN_QUOTE
    Como el tamaño de la información es muy extensa, no alcanzaria el espacio del PCB ó los Registros (del CPU),
    por eso *solo se guarda la referencia de la Página del Proceso a la Tabla de Páginas*
    #+END_QUOTE
    
    *Observaciones:*
    - En un puntero se guarda la referencia de la Página a la Tabla de Páginas
*** [WAITING] Estructura
    - Cada *Proceso* tiene una *Tabla de Páginas* (que indica en que Marco se encuentra c/Página)
    - Cada *Página* tiene un *BIT de validéz* (indica si está en el *Espacio de Direcciones* del Proceso)
    - Valores del *BIT de validez*
      - Si es ~1~, es porque pertenece al *Espacio de Direcciones* del Proceso
      - Si es ~0~, y se intenta acceder a esa Página dará ERROR, porque no pertenece a ese Proceso

    #+BEGIN_COMMENT
    Si las *direcciones* son de ~32 bits~, y las *Páginas* de ~1KiB~ (2^10),
    entonces la (TP) Tabla de Páginas puede tener ~2^32/2^10 = 2^22~ osea ~2^22~ *entradas*,

    dividimos el *tamaño de las direcciones* por el *tamaño de página*
    porque..

    Si cada *entrada* es de ~4 bytes~, entonces una (TP) puede ocupar ~16MiB~ => 16MiB contiguos en (MP)
    porque ~4Mib * 2^22 entradas = 16MiB~

    y.. si las direcciones son de ~64 bits~...
    #+END_COMMENT
*** Bitmap
    - Para administar los *Marcos* libres
    - Como todos los *Marcos* van a tener el mismo tamaño, no necesitamos saber el tamaño
      con saber sólo el número de marco es suficiente (similar a las Particiones Fijas)

    #+name: bitmap-marcos-libres
    |---+---+---+---+---+---+---|
    | 1 | 1 | 1 | 0 | 1 | 0 | 1 |
    |---+---+---+---+---+---+---|
*** Ejemplo 1
    Suponiendo que tenemos un proceso (A), en su tabla de páginas se guardan 3 referencias/punteros
    a los marcos de las páginas de ese proceso.
    - La página 0 del proceso A, apunta al marco 5 de la RAM
    - La página 1 del proceso A, guarda la referencia al marco 6
    - La página 2 del proceso A, tiene un puntero al marco 2

    Las páginas 0,1,2 de ese proceso en su tabla de paginas, tiene el bit de validez en 1
    eso indica que están en el *espacio de direcciones* de ese proceso (A)

    #+BEGIN_COMMENT
    Ej. si el ~tamaño_pagina = 1KiB~ => ~DL=2045~ (decimal)
    ~DL/Tamanio_Pagina = Numero_Pagina~ y..
    el *resto* de la división es el *OFFSET* (desplazamiento en esa página)

    2045/1024 = numero_pagina,
    por tanto ya conocemos que ~pagina=1~ y ~offset=1021~
    por tanto si vemos en la "tabla de paginas" la pagina=1
    tiene ~marco=6~ y como el ~bit_de_validez=1~ pertenece a un *espacio de direcciones* del proceso

    Como ya sabemos el marco, offset y también el tamaño de marco,
    porque es el mismo que el tamaño de página.. Calculamos la *dirección física* (DF)
    
    ~Direccion_Fisica = Numero_Marco * Tamanio_Marco + OFFSET~
    direccion_fisica = 6 * 1024 + 1021 => ~direccion_fisica = 7165~
    #+END_COMMENT

   #+name: tabla-de-paginas-de-un-proceso
   |----------+-------+----------------|
   | Num Pag. | MARCO | bit de validéz |
   |----------+-------+----------------|
   |        0 | 5     |              1 |
   |      ~1~ | 6     |              1 |
   |        2 | 2     |              1 |
   |        3 | -     |              0 |
   |        4 | -     |              0 |
   |        5 | -     |              0 |
   |----------+-------+----------------|

   #+name: memoria-principal
   |-----------+-----|
   | Nro Marco |     |
   |-----------+-----|
   |         0 |     |
   |         1 |     |
   |         2 | PA2 |
   |         3 |     |
   |         4 |     |
   |         5 | PA0 |
   |       ~6~ | PA1 |
   |         7 |     |
   |         8 |     |
   |         9 |     |
   |-----------+-----|
*** [TODO] Ejemplo 2
    quedó incompleto el ejercicio...
    
    Si la pagina es de 1KiB => necesitamos ~10 bits~ para direccionar 1 byte dentro de la misma,
    porque ~1KiB = 2^10 = 1024~
    Si la página era de 4KiB => necesitamos ~12 bits~ porque ~2^12~ es ~4 KiB~

    #+name: direccion-logica
    |---------------+---------------------------------|
    | numero pagina | offset dentro de pag. (10 bits) |
    |---------------+---------------------------------|

    2045(d) -> 11...01 (b)
    1 | 11...01 -> offset

    pag. 1 (b) => 1 (d)

    #+name: direccion-fisica
    |--------------+-----------------------------------|
    | numero marco | offset dentro de pagnia (10 bits) |
    |--------------+-----------------------------------|
    |          110 | 11...01                           |
    |--------------+-----------------------------------|

    
   #+name: tabla-de-paginas-de-un-proceso
   |----------+-------+----------------|
   | Num Pag. | MARCO | bit de validéz |
   |----------+-------+----------------|
   |        0 | 5     |              1 |
   |        1 | 6     |              1 |
   |        2 | 2     |              1 |
   |        3 | -     |              0 |
   |        4 | -     |              0 |
   |        5 | -     |              0 |
   |----------+-------+----------------|
** [TODO] Puntero (PTBR)
   - El ~PTBR~ contiene el puntero de la *tabla de paginas* del proceso en ejecución
   - Su valor se debe guardar en los *cambios de contexto*
   - El valor se va a cambiar cada vez que cambiemos de procesos (switch process)
** TLB (Memoria Caché de HW)
*** Conceptos
    - Es el *Translation look-aside buffer*
    - Es como una *caché* para la *tabla de páginas*
    - Se guardan los valores cada vez que se accede a la (TP, Tabla de Páginas)
    - Primero se tiende a acceder primero a esta *caché*, caso contrario va a la *tabla de páginas*
    - Es una memoria asociativa de alta velocidad a nivel de hardware (actúa de *caché*)
    - Guardan _entradas de tablas de páginas_
    - Agilizan el acceso, aumenta la velocidad de acceso
 
    TP: Tabla de paginas

    #+BEGIN_QUOTE
    Un acceso a una dirección fisica, implica 2 accesos a memoria porque
    1. primer acceso en la tabla de paginas (TP)
    2. segundo acceso a la dirección física (DF) byte (???)

    En cada entrada de pagina puede guardar tambien el identificador del proceso
    (para proteger otros procesos, y evitar vaciar la cache en cada switch process)
    #+END_QUOTE
*** TLB Miss
    Si accedi a la TLB, NO encontré el valor, y luego fui a la TP
    (por tanto accedi 2 veces)
*** TLB Hit
    Si accedí a la TLB y encontré el valor
*** [TODO] Ejemplo
    Si usamos la fórmula
    ~tiempo_acceso - efectivo = p_acierto * tiempo_acierto + p_fallo * tiempo_fallo~

    0,98*(20ns + 100ns) + 0,02 *(20ns +....
** Protección y compartir memoria entre procesos
*** Protección
    - Se pueden agregar bits en la (TP) para agregar permisos sobre las páginas
*** Memoria compartida
    - Los procesos pueden compartir memoria, apuntando a los mismos *marcos* en la (TP, Tabla de páginas)
      
    #+BEGIN_COMMENT
    es decir van a compartir páginas, porque los procesos están divididos en *páginas*
    #+END_COMMENT
** Paginación Jerárquica
*** Conceptos
   - Para paginar la *Tabla de Páginas* (TP)
   - Para tener distintos niveles de Tabla de Páginas (/guardar referencias en una TP a otras TP, y estas a otras../)
   - Soluciona el problema de tener *Tablas de Páginas* MUY GRANDES
   - Divide el problema de (TP) grandes en varias (TP) más chicas
    (/si no, se tendria el mismo problema que con las estructuras contiguas en memoria../)
*** [TODO] Tabla de Páginas Jerárquica
    Con las sig. tres referencias se define la *Dirección Física* (DF) a partir de una *Tabla de Páginas Jerárquica*
    - *Página TP Global*: Es un puntero/referencia a la *tabla de páginas global* (la que guarda referencias a otras TP)
    - Direccion Lógica (DL)
      - *Offset TP*: Es un puntero a una *Tabla de Paǵinas* (TP)
      - *Offset*: Es un puntero a un Marco de Página

    #+BEGIN_QUOTE
    Ahora hay 3 accesos a memoria, más accesos que paginación simple
    1. Un acceso a TP de 1º nivel (TLB)
    2. Un acceso a TP de 2º nivel
    3. Un acceso a Memoria
    #+END_QUOTE
    
   #+name: tabla-de-pagina-jeraquica-de-2-niveles
   |----------------+-----------+---------|
   | Pag. TP Global | Offset TP | Offset  |
   |----------------+-----------+---------|
   | 10 bits        | 10 bits   | 12 bits |
   |----------------+-----------+---------|
*** Ejemplo 1- Con hexadecimal
    Si tenemos la siguiente dirección fisica en hexadecimal del proceso A:
    ~PA AA BB 1234h~

    Podemos separarla en
    - offset: 1234
    - Numero de pagina: AA BB
    - Numero de página global: AA
    - Numero de página de 2do nivel: BB

    1. Intentamos acceder al ~TLB~ con AABB (nos va a tirar que no está, por ser primer acceso)
       TLB -> AABB -> no!
    2. Entonces accede al número de página global del proceso A, obtiene el marco
       TPG PA -> AA -> Marco=30 
    3. Ahora con ese marco y el numero de pagina de 2do nivel, accede al marco de esa 2da TB
        MARCO 30 => BB => MARCO 100 <--- este es el marco IMPORTANTE..!!!
    4. Define la Dirección Fisica, hacemos la traducción
       DF -> MARCO | OFFSET
    5. Podemos guardar en el TLB el *marco* de ese *numero de página* para acceder más rapido
       TLB -> AA BBh = 100

    Ahora.. si queremos acceder nuevamente pero desplazarnos, reutilizamos lo que teniamos en el TLB
    para un acceso más rapido

    6. PA AA BB 0222h    <--- el numero de pagina es: AA BB
    TLB-> AA BB -> 100   <--- ya reconoce que el *marco* de ese *numero de página* tiene 100 de dirección
    DF -> MARCO | OFFSET <--- volvemos a definir la dirección fisica

    *Conclusión:*
    - Sin el TLB, tuvimos 3 accesos a RAM (1 TPG + 1 TP 2do nivel + 1 Marco 100)
    - Con el TLB (con ~hit~), tuvimos 1 acceso a RAM (Marco 100)+ 1 acceso a la *caché*
** Tabla de Paginas Invertida
*** Conceptos
    - Es una tabla más grande que la de un proceso, pero más chica que la suma de las tablas de todos los procesos
    - Está indexeado por el *número de Marco* (_busca secuencialmente_ por el Marco como índice)
    - Consiste en tener una única *Tabla de Paginas* (TP) en vez de una por cada proceso
    - Hay tantas *Entradas* como *Marcos* tenga la memoria (/porque ahora el número de Página es el número de Marco/)

    #+BEGIN_COMMENT
    <<DUDA>>: Por que NO se puede compartir memoria entre procesos?

    *Respuesta:*
    Porque en esta tabla, se entra por el número de *Marco*,
    y esta dice el número de página de que proceso está en ese *Marco*
    #+END_COMMENT

    #+BEGIN_QUOTE
    En las TP normales el INPUT (entrada) es el *número de Página*,  y el OUPUT el *número de Marco*.

    En las tablas de paginas invertida, es al revés..
    el INPUT es el *número de Marco*, y el OUTPUT el *número de Página*
    #+END_QUOTE
*** Ventajas
    - Ocupa menos espacio que las *Tablas de Páginas* comunes en (MP)
*** Desventajas
    - NO soporta el *compartir memoria* entre procesos (/en el esquema comun de TB era más fácil/)
    - Puede generar *colisiones* (depende del dominio entrada, y la dispersión que genere) entre *funciones de hash*
    - Depende de las *funciones de hash* para que sea eficiente el *tiempo de acceso*, caso contrario haría *búsquedas secuenciales*
      (/chequeando que marco está libre para agregar una página/)
*** Tabla de hash
    - Mejora el tiempo de acceso 
    - Para optimizar la *tabla de paginas invertida* (mejora el tiempo de acceso, si no esa tabla seria INEFICIENTE)
    - Las *funciones de hash* evitan las *busquedas secuenciales* (que hacen lenta la busqueda)

    #+BEGIN_QUOTE
    Utilizan *funciones de hash* que reciben como entrada la *Página del proceso*
    realiza un cálculo que tiene como salida el numero *Marco* (frame) que debería tener asignado esa página,

    suponiendo que ese numero de *Marco* no estuviera libre, volvería a realizar el cálculo de dispersión
    y devolvería otro número de Marco (como si diera saltos)
    #+END_QUOTE
** Ejemplo 1 - Calcular DF con decimales
*** 1. Datos
    Si nos dan el tamaño de la página, la dirección lógica (DL)
    debo saber cual es la *página* para luego obtener el *marco*

    #+name: tabla-paginas-proceso-A
    |----------+-------+-------------|
    | Nro Pag. | Marco | bit_validez |
    |----------+-------+-------------|
    |        0 |     5 |           1 |
    |        1 |     6 |           1 |
    |        2 |     2 |           1 |
    |        4 |     - |           0 |
    |        5 |     - |           0 |
    |----------+-------+-------------|

    Datos:
    - tamaño de pagina = 1KiB (1024)
    - DL = 2045 (decimal) 
*** 2. Calculamos numero de pagina
    Para saber el *número de página*, dividimos la dirección_logica por el tamanio_de_pagina
    es decir numero_pagina = direccion_logica / tamanio_pagina

    ~numero_pagina = 2045/1024~ => numero_pagina = 1, offset (desplazamiento) = 1021 bytes
*** 3. Accedemos a la tabla de paginas
    Para acceder a esa dirección lógica, debemos ir a la *tabla de páginas*
    vamos a la ~pagina_numero=1~, esta guarda una referencia ~marco=6~ y verificamos
    que se cumpla ~bit_validez=1~
*** 4. Calculamos la dirección fisica (DF)
    Para saber la *dirección física* (la que entiende la RAM y se encuentra ahí fisicamente)
    multiplicamos el numero_marco por el tamanio_marco, y le sumamos el ~offset~.
    (/Multiplicamos el número de marco por su tamaño, porque todos los marcos tienen mismo tamaño/
    /y le sumamos el offset, porque es el desplazamiento, el que tanto se desplaza/)

    Entonces...
   ~direccion_fisica = numero_marco * tamanio_marco + offset~
   => direccion_fisica = 6 * 1024 + 1021 
   => direccion_fisica = 7165

   *Observación:*
   El tamaño de página es igual al tamaño de marco, entonces ~tamanio_pagina = tamanio_marco~

** [TODO] Ejemplo 2 - Calcular DF con binarios
*** 1. Datos
    - Tamanio de la pagina: 1KiB (1024)
    - DL = 2045 (decimal) => DL =1111111101 (en binario con bits)

    #+BEGIN_QUOTE
    Para direccionar 1 byte dentro de una página de 1KiB, necesitamos ~10 bits~ 
    porque 2^10=1024 y 1Kib=1024 bytes. Esos 10 bits, serán los *bits de menor peso*,
    y el numero de página los *bits de mayor peso*
    #+END_QUOTE

    #+name: tabla-de-paginas-proceso-A
    |------------+-------+----------------|
    | num pagina | marco | bit de validez |
    |------------+-------+----------------|
    |          0 | 5     |              1 |
    |          1 | 6     |              1 |
    |          2 | 2     |              1 |
    |          3 | -     |              0 |
    |          4 | -     |              0 |
    |          5 | -     |              0 |
    |------------+-------+----------------|
*** 2. Calculamos el número de página
    ~numero_pagina = direccion_logica/tamanio_pagina~
    
    Igual que en ejemplo (1) hacemos
    ~numero_pagina = 2045/1024~ => numero_pagina = 1, offset (desplazamiento) = 1021 bytes

    si pasamos el ~offset~ a binario, nos queda..
    ~offset = 1111 1111 01~ (en binario)

    #+BEGIN_COMMENT
    1021 bytes en hexadecimal es 
    #+END_COMMENT
*** 3. Calculamos la dirección logica (DL)
    Sólo necesitamos
    1. numero de pagina
    2. offset dentro de página

    #+name: direccion-logica
    |---------------+------------------|
    | numero_pagina | offset (10 bits) |
    |---------------+------------------|
    |             1 |       1111111101 |
    |---------------+------------------|
*** 4. Calculamos la dirección física (DF)
    Pasamos el número de marco que daba ~6~ a binario..
    ~numero_marco = 110~ (en binario)

    Sólo necesitamos
    1. numero de marco
    2. offset dentro de página

    #+name: direccion-fisica
    |--------------+------------------|
    | numero_marco | offset (10 bits) |
    |--------------+------------------|
    |          110 |       1111111101 |
    |--------------+------------------|
* Calcular Numero de Pagina y Direccion Fisica

  |-------------------------+------------------------------------------------------------|
  | Numero de página        | ~numero_pagina = direccion_logica / tamanio_pagina~        |
  |                         |                                                            |
  | Offset (Desplazamiento) | ~offset = direccion_logica % tamanio_pagina~               |
  |                         |                                                            |
  | Tamaño de marco         | ~tamanio_pagina = tamanio_marco~                           |
  |                         |                                                            |
  | Dirección Fisica        | ~direccion_fisica = numero_marco * tamanio_marco + offset~ |
  | (en decimal)            |                                                            |
  |                         |                                                            |
  | Dirección Fisica        | ~direccion_fisica = numero_marco I offset~                 |
  | (en binario)            |                                                            |
  |                         |                                                            |
  | Dirección logica        | ~direccion_logica = numero_pagina I offset~                |
  | (en binario)            |                                                            |
  |-------------------------+------------------------------------------------------------|

  *Observación:*
  - el resto de la división es el ~offset~, osea el desplazamiento
  - el resto aparte de la divisón, también resulta de calcular el módulo con el operador % 
* Segmentación (Simple)
** Conceptos
   - Los *Segmentos* son de *tamaño variable*
   - Se divide la *imagen* de los procesos en pequeños *segmentos* de tamaño variable (c/u con una base diferente)
   - Similar a *Partición Dinámica*
** Tabla de segmentos
   - Por cada *proceso* habría una *Tabla de Segmentos*
   - Cada *segmento* del proceso tiene un *tamaño* diferente y una *base* diferente
** Proceso de traducción
   - Se chequea ~OFFSET < LIMITE~ (menor estricto) donde el *OFFSET* es desplazamiento y el *Limite* es el tamaño
   - Para un proceso se tienen varias *bases* y *limites* (por los segmentos)
   - La última *dirección* válida es ~LIMITE - 1~
** Diferencias con Paginación
   #+BEGIN_QUOTE
   Algunas diferencias entre *Segmentación* y *Paginación*
   - En *Segmentación* NO se divide la memoria en *particiones*,
     si no que asignan *segmentos* (de tamaño variable) según se necesite.

   - Existe *fragmentación externa* pero es menor que *partición dinámica* porque no se aloca la *imagen* entera del proceso,
     se aloca pequeños *segmentos* (código, datos, pila, ..)

   Para un proceso le asignan varias particiones chicas (dinámicas),
   #+END_QUOTE
** Semántica
   A diferencia de las *particiones* los *segmentos* toman un significado
   1. Segmento de Código (CS)
   2. Segmento de Datos (DS)
   3. Segmento de Pila (SS)
** Permisos
   Al tener una semántica asociada, se les puede agregar *permisos* (R,W,X)
   - (R)ead
   - (W)rite
   - E(x)ecute
** Desventajas
   - Aparece la *fragmentación externa*
     - Es mínima comparado con las *Particiones Dinámicas* (porque se alocan pequeños segmentos del proceso, en vez de toda la imagen del proceso)
     - Se debe recurrir a la *Compactación* (desplazar los segmentos en memoria)
** Ventajas
   - NO hay *Fragmentación Interna*
** Dirección Lógica
   Se forma con ~numero_segmento + offset~
** Almacenamiento
   Los *segmentos* se guardan de forma *contigua* en la *Memoria Principal* (MP)
* Segmentación Paginada
** Conceptos
   Agarra las ventajas de *paginación* y de *segmentación*
** Reutiliza de paginación
  - La *memoria principal* sigue dividida en *marcos*
  - Podemos tener *tablas de páginas* para los *segmentos*
** [TODO] Reutiliza de segmentación
   - Las particiones tienen una semántica, y se les _puede agregar permisos_ (R,W,X)
   - Tiene más *Fragmentación Interna* que la *Paginacion Simple* (en la última página de cada segmento)
   - Tiene *Fragmentación Externa* pero mínima, porque separa la memoria en *Marcos* (frames)
   - Los *segmentos* tendrá un conjunto de páginas
** Segmentation Fault
   - Cuando intentamos acceder a un número de segmento que NO está en la *tabla de segmentos* (tiene el bit_de_validacion=0)
     
   #+BEGIN_COMMENT
   Cuando el número de segmento a acceder es mayor
   #+END_COMMENT
* Tabla Comparativa
 |--------------+---------------------------------------+-------------------------------+------------------------------|
 | TECNICA      | DESCRIPCIÓN                           | VENTAJAS                      | DESVENTAJAS                  |
 |--------------+---------------------------------------+-------------------------------+------------------------------|
 | Particiones  | La memoria se divide                  | - Poco ~overhead~             | - Limita la cant. de         |
 | Fijas        | en particiones de                     | - Fácil de implementar        | de procesos                  |
 |              | igual tamaño                          |                               | - Fragmentacion Interna      |
 |--------------+---------------------------------------+-------------------------------+------------------------------|
 | Particiones  | Las particiones se ajustan            | Se usa la memoria de          | - Fragmentación externa      |
 | Dinámicas    | al tamaño de los procesos             | manera eficiente              | - Compactación               |
 |              |                                       |                               | - Más dificil de implementar |
 |--------------+---------------------------------------+-------------------------------+------------------------------|
 | Paginación   | La memoria se divide en marcos        | - NO hay frag. externa        | - Fragmentacion interna      |
 |              | de igual tamaño                       | - Las pág. no son ~contiguas~ | (en la última pagina)        |
 |              | Los procesos se dividen en páginas    |                               | - Muchas estructuras         |
 |              | de igual tamaño                       |                               |                              |
 |              | El tamaño de los marcos y las páginas |                               |                              |
 |              | es el mismo                           |                               |                              |
 |--------------+---------------------------------------+-------------------------------+------------------------------|
 | Segmentación | Los procesos se dividen en segmentos  | - NO hay frag. interna        | - Fragmentacion externa      |
 |              | de diferentes tamaños                 |                               | (aunque es minima)           |
 |--------------+---------------------------------------+-------------------------------+------------------------------|
* Buddy System
** Conceptos
   Es una estrategia que junta las estrategias de *asignación contigua* y minimiza sus desventajas
   - *Particiones Fijas* (limitaba el tamaño, y cant. de procesos)
   - *Particiones Dinámicas* (huecos entre particiones, compactación)
** Búsqueda y división - Definir tamaño partición
   Define el tamaño de la *partición* a asignar *dinámicamente*
   1. _Busca el bloque de potencia de 2 más chico_, que cumpla con lo pedido (se denominan *buddies*)
   2. Si NO existe el bloque => _divide en dos al bloque más cercano_ a ese tamaño
   3. Repite la búsqueda (y vuelve al ciclo)
** Buddy
    - Representa cada bloque que resulta de dividir en dos a otro más grande durante la búsqueda
    - Dos bloques A y B son *buddies* si y sólo si
      1. Tienen igual tamaño
      2. Son contiguos (uno al lado del otro)
      3. ~(direccion_inicio_A = direccion_inicio_B XOR tamanio_A) && (direccion_inicio_B = direccion_inicio_A XOR tamanio_B)~ (operador XOR)
** Operador XOR
*** Conceptos
    - Cuando ambos son diferentes dará 1 (ej. 1 y 0, 0 y 1)
    - Cuando ambos son iguales dará 0 (Ej. 0 y 0, 1 y 1)

    |---+---+-------+-----+----|
    | A | B | ~XOR~ | AND | OR |
    |---+---+-------+-----+----|
    | 0 | 0 |     0 |   0 |  0 |
    | 0 | 1 |     1 |   0 |  1 |
    | 1 | 0 |     1 |   0 |  1 |
    | 1 | 1 |     0 |   1 |  1 |
    |---+---+-------+-----+----|
*** Aplicado en Buddy System
    Si tenemos dos bloques A, B que son buddy (contiguos, y son resultado de dividir en dos uno más grande)
    - Operamos la ~direccion_bloque_A XOR tamanio_bloque_b~
    - El _resultado es el comienzo de dirección de memoria_ de su *buddy* (bloque contiguo, de igual tamaño)

    Supongamos que partimos de dos bloques de ~16k~ (con dirección de 0 a 8, y el otro de 16 a 28)
    1. Dividimos en primer bloque de ~16k~ en dos de ~8k~ (primero y segundo bloque)
    2. Didivimos el segundo bloque en dos de ~8k~, y el segundo en otros dos de ~4k~ (cuarto y quinto bloque, son buddies)

    |----+----+----+----+----|
    |  0 |  8 | 16 | 24 | 28 |
    |----+----+----+----+----|
    | 8k | 8k | 8k | 4k | 4k |
    |----+----+----+----+----|

    *Caso A:*
    1. Se libera la segunda partición (tamaño=8K, dir_inicial=8)
    2. Hacemos ~8 XOR 8~ (esa operación representa: direccion_inicial_del_segundo_bloque ~XOR~ tamaño_de_su_buddy)
       nos queda ~8 XOR 8 = 1000 XOR 1000 = 0000 => 8 XOR 8 = 0~ 
       siendo ese resultado 0 la dirección del buddy (la partición 1)
    
    *Caso B:*
    1. Se libera la quinta partición (tamaño=4K, dir_inicial=24)
    2. Hacemos ~24 XOR 4 = 1100 XOR 100 = 11100 = 28 => 24 XOR 4 = 28~
       siendo el resultado ~28~ el comienzo de la dirección del buddy de la quinta partición
** Liberación de Bloques
   Es el paso inverso al de búsqueda y divisón, del definir el tamaño de la partición
   + Se debe validar que su *buddy* esté libre
     - Si está libre    => se *consolidan* (los dos en un solo bloque)
     - Si NO está libre => sólo se libera ese bloque
   + El *buddy* de un bloque
     - es el otro bloque que se formó como resultado de dividir un bloque más grande en dos
     - es el bloque contiguo de igual tamaño

   *Observación:*
   - *Consolidar* se refiere a _unir dos bloques en uno_
** Estructura - Datos
   En la estructura del bloque se guardan los datos, y un header
   1) datos
   2) header
      - el tamaño del bloque (sólo se guarda la potencia 2^n)
      - si el buddy esta libre

  #+BEGIN_QUOTE
  Al momento de *liberar un bloque* chequea el header, y verifica si su buddy está libre

  si su *buddy* está libre => consolida los dos bloques (los junta en uno solo)
  #+END_QUOTE

  *Observación:*
  - Con el Header podemos determinar si su buddy está libre, y el tamaño del bloque

  #+name: bloque
  |----------------+-------|
  | HEADER         | DATOS |
  |----------------+-------|
  | LIBRE I TAMAÑO |       |
  |----------------+-------|
** Implementación
*** Arbol Binario
    - porque cada particion inicial se divide en dos
*** Listas enlazadas
    Los bloques se referencian entre ellos
*** Bitmap de bloques
    - para cada nivel
    - uno por cada tamaño de partición posible

    Ej. particiones de 512
    |---+---+---+---|
    | 1 | 1 | 0 | 1 |
    |---+---+---+---|

    Ej. particiones de 128
    |---+---+---+---+---+---+---+---|
    | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 1 |
    |---+---+---+---+---+---+---+---|

    Ej. particiones de 64
    |---+---+---+---+---+---+---+---+---+---+---+---+---+---|
    | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 1 | 1 |
    |---+---+---+---+---+---+---+---+---+---+---+---+---+---|
** Ventajas
   #+BEGIN_QUOTE
   Estas comparaciones son contra los *Esquemas de asignación contigua*
   no contra *Paginación*
   #+END_QUOTE
   
   - Mayor velocidad para la búsqueda de bloques libres
   - Facilidad para búsqueda del bloques libres (por el operador ~XOR~)
   - Mayor velocidad de *consolidación* (juntar dos bloques en uno solo)
   - Menor fragmentación interna (/a diferencia de Partición Dinámica le asignaba el mismo tamaño a todas/)
   - Menor fragmentación externa
   - Menos frecuente la *compactación*
** Desventajas
   + Hereda los problemas de las particiones fijas/dinámicas (en menor medida)
     - Fragmentación Interna
     - Fragmentación Externa
   + Requiere *compactación* (aunque en menor medida) por tanto genera ~overhead~
     (pero es necesaria para evitar la fragmentación externa)
     
   #+BEGIN_COMMENT
   Limita la cant. de procesos
   #+END_COMMENT

