#+TITLE: Clase 08 - Memoria Virtual
#+STARTUP: inlineimages

#+BEGIN_COMMENT
Te quedaste en clase 9 - algoritmos y casos especiales - 35:42
con el *clock modificado*
#+END_COMMENT

* Problema
  #+BEGIN_QUOTE
  El *proceso* tiene que estar TODO cargado en (RAM) para poder ejecutar,
  
  esto implíca limitar el tamaño máximo del proceso (/para que no supere el tamaño de la RAM/)
  #+END_QUOTE
* Primeras Soluciones
** Técnica de Overlaying
  - La técnica de *Overlaying* consta en dividir un proceso en varias capas
  - Consta en cargar a memoria sólo las capas del proceso que necesitamos
  - Es útil cuando tenemos procesos que queremos ejecutar pero son más grandes que la RAM
  - A cada proceso se lo secciona en
    1) *Overlay driver*: tiene la lógica de cuando cargar/descargar secciones/capas (overlays) en memoria
    2) *Sección principal*: alguna rutina que va estar ejecutando always..
    3) *Overlays*: son partes del proceso que vamos a necesitar en distintos momentos

  *Observaciones:*
  - Estas son soluciones a nivel de RAM, no a nivel de Sistema Operativo
** Ejemplo
   Un proceso se podrí seccionar en
  #+NAME: proceso-a
  |-------------------|
  | OVERLAY DRIVER    |
  |-------------------|
  | SECCION PRINCIPAL |
  |-------------------|
  | OVERLAY 1         |
  |-------------------|
  | OVERLAY 2         |
  |-------------------|
  | OVERLAY 3         |
  |-------------------|
  | OVERLAY N         |
  |-------------------|

  En RAM tendriamos
  - El *Overlay Driver* quien tiene la lógica para cargar/descargar las capas a memoria
  - La *Seccion principal* que se va a estar ejecutando todo el tiempo
  - La capa (overlay) que necesitamos cargar en memoria (parte del proceso)
  
  #+NAME: memoria
  |-------------------|
  | OVERLAY DRIVER    |
  |-------------------|
  | SECCION PRINCIPAL |
  |-------------------|
  | OVERLAY SECCION   |
  |-------------------|
* Solución Valida
** Intro para Memoria Virtual
  - Tener *direcciones lógicas* más grandes que la RAM
    (/le mentimos a los procesos que le asignaremos tanto espacio/)
  - Cargamos partes en *RAM* y partes *Swap* (en disco)
  - Un *proceso* puede dividirse en *partes* (concepto de Paginación)
    - pueden estar o no *contiguas* en *(MP)*
    - pueden estar en la *Memoria Virtual*

  *Observaciones:*
  - Las referencias a memoria dentro de un proceso son *direcciones lógicas* (DL)
  - Las *direcciones lógicas* son traducidas a *direcciones físicas* (DF) en *tiempo de ejecución*
** Ventajas
   - Más procesos en memoria => implíca aumentar el *grado de multiprogramación*
   - Mayor tamaño para los procesos => la *MP* ya no limita
* Memoria Virtual
** Conceptos
  + La Memoria Virtual se forma con (~RAM + SWAP = Memoria Virtual~)
    1. Memoria Principal (RAM) <--- Páginas de los procesos
    2. Disco SWAP (Almacenamiento Secundario)
  + Los procesos que están en ejecución
    - En la *Memoria Virtual* aparece su *número de Marco*
    - En la *Memoria Principal* aparece su *número de Página*

  *Observaciones:*
  - Las *instrucciones* deben estar en RAM para estar en ejecución
  - El disco (SWAP) tiene mayor capacidad que la RAM
** Diagrama
  #+BEGIN_SRC plantuml :file img/mem-virtual-1.png :exports results
    @startuml
    
    package "RAM + Disco SWAP" as p1{
        note as A
        ,**Memoria Principal (RAM)**
        Instrucciones de varios procesos en ejecución
        | 0| Pag1 ProcesoA |
        | 1| Pag1 ProcesoA |
        | 2| Pag1 ProcesoA |
        | 3| Libre |
        end note
        
        note as B
        ,**Disco SWAP**
        (Almacenamiento secundario)
        end note
    }
    
    note as C
    ,**Memoria Virtual**
    Frames del Proceso A
    |0 | NO en RAM|
    |1 | Frame 0|
    |2 | NO en RAM|
    |3 | NFrame 3|
    |4 | NO en RAM |
    end note
    
    p1 -down-> C
    @enduml
  #+END_SRC

  #+RESULTS:
  [[file:img/mem-virtual-1.png]]

** Paginación bajo demanda
*** Conceptos
    - Las *páginas* se cargan a medida que se necesita en *Memoria Física/Real* (RAM)
    - El tiempo de carga de los procesos es menor
    - Se agregan operaciones de disco a diferencia de la técnica de *Overlaying*

    #+BEGIN_COMMENT
    <<DUDA>>
    El tiempo de carga de los procesos es menor porque...
    #+END_COMMENT

    #+BEGIN_QUOTE
    El *swapping* es *lazy* porque sólo se mueven *páginas* del proceso,
    en vez de todo el proceso entre MP y SWAP
    #+END_QUOTE
*** Tabla de Páginas
    - A la *tabla de páginas* se le agrega el *bit de presencia* y el *bit modificado*
    - Si el valor del *marco* no aparece => no se cargó a *RAM* aún
   
    #+name: procesos-en-memoria-fisica 
    |----------+-------+---+---|
    | Num Pag. | Frame | P | M |
    |----------+-------+---+---|
    |        0 |     - | 0 | 0 |
    |        1 |     2 | 0 | 0 |
    |        2 |     7 | 1 | 1 |
    |        3 |     2 | 1 | 0 |
    |----------+-------+---+---|

    Referencias de la tabla:
    - ~P~ es el *Bit de Presencia*
    - ~M~ es el *Bit de Modificado*
    - ~Frame~ es el *Número de Marco*
*** BIT de Presencia (P)
    Indica si una *página* está o no en *RAM*
    - Si ~P=0~: NO está en MP (quizás estaba) 
    - Si ~P=1~: SI está en MP

    *Observaciones:*
    - Si se referencia una *página* con ~P=0~ => la *MMU* lanzará una interrupción por *Fallo de Página* (PF, Page Fault) que atenderá el SO
    - La *MMU* es la *Unidad de Manejo de Memoria*
      1. Es el nexo entre la CPU y la MP
      2. Es quien traduce las direcciones para que la MP las entienda (de DL a DF)
*** BIT Modificado (M)
    - Se habilita siempre que se modifique una página
    - Asegura la consistencia y evitar hacer operaciones de disco innecesarias
    - Se habilita siempre que se acceda a una página en *modo escritura* (hubo un acceso a disco)
    - Indica si una *página* la última vez que se trajo fue modificada o no
      - Si ~M=0~: 
      - Si ~M=1~: Indica que la página fue modificada (/y tenemos que bajar los cambios a disco/)

    #+BEGIN_QUOTE
    Si accedíamos a una página N en *MODO de Escritura* que tiene el *BIT de Modificado* en ~M=0~,
    entonces lo debemos habilitar quedando ~M=1~ y esto nos evita una operación de disco

    Si volvemos a acceder a la misma página N y tenía el *BIT de Modificado* en ~M=1~,
    entonces sólo accedemos, no necesitamos modificar el *BIT de Modificado*
    y como el caso anterior tampoco hacemos una operación de disco porque ya estaba en memoria
    #+END_QUOTE
*** Swapping
    - Concepto de mover *paginas* entre *SWAP* (disco) y *RAM* (MP)
    - Evita tener que mover un proceso entero a RAM
** Atención Page Fault (PF)
*** Conceptos
    1. Comprobar si la *dirección* de un proceso es valida ó no
       (Se cumple si está dentro del *espacio de direcciones* de ese proceso)
    2. Si la _referencia NO es válida_ entonces
       - Se finaliza el proceso
       - ó Se envía un mensaje de error (y sigue con la sig. referencia a memoria)
    3. Si la _referencia es válida_, entonces
       1. Se lanza una *operación de lectura* para leer la página (/Int. de I/O/)
          - Se carga la página en el *marco* elegido
          - Si no hubiese ningún marco libre, se desalojará alguno
       2. Cuando termina la *Interrupción de IO* (lectura en disco)
          - se modifica en la *Tabla de Páginas* el *BIT de Presencia* en 1 osea ~P=1~
            (indicando que la página se encuentra en memoria)
       3. Se reinicia la *instrucción* que dió origen a la *Interrupción de IO*

    #+BEGIN_QUOTE
    El proceso que generó (PF; Page Fault) va a quedar en estado *bloqueado*,
    hasta que esa página que se necesita esté cargada en RAM.

    Cuando la página esté en memoria
    1. el proceso pasa a READY
    2. debe esperar a ser elegido, pasando a estado RUNNING
    3. el proceso debe volver a ejecutar la instrucción que había generado la Interrupción de IO
    #+END_QUOTE
*** Diagrama Básico
    #+BEGIN_SRC plantuml :exports results :file img/page-fault-1.png
      @startuml
      (*) --> "Comprobar dirección"

      if "si es valida" then
              --> "Interrupción I/O"
              if "hay marco disponible" then
                      --> "Cargar página en el marco"
                      --> "Modificar Bit de presencia = 1"
                      --> "Reiniciar instrucción"
              else
                      --> "Desalojar un marco"
              endif
      else
              --> "Finaliza proceso ó Rechaza"
      endif
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/page-fault-1.png]]
** Proceso Traducción de DL a DF
   1. La *CPU* ejecuta una *instrucción* (que referencia a una Página de un proceso)
   2. Se busca en la *TLB* (busca en Memoría Caché de HW)
      - _TLB HIT_: Define la *DF* (recupera el *marco* y lo usa para definirla)
      - _TLB MISS_: Busca en *TP* (del proceso)
        1. Si ~P=1~ (está en *MP*) => Agrega la entrada en la *TLB* (prox. acceso + rápido) -> Define *DF*
        2. Si ~P=0~ (NO está en *MP*) => Interrupción por *PF* -> *SO* atiende Int. (con el Interrupt Handler)
           1. Si está fuera del *espacio de direcciones*  (del proceso) -> Fin de proceso ó Devolver error
           2. Si está dentro del *espacio de direcciones* (del proceso) -> Busca un *marco* libre en MP (/le asigna a la Página un lugar/marco en RAM/)
              1. Si hay *marco* libre => se lanza Int. de I/O (operación de lectura, para traerse la página de SWAP, bloqueando al proceso) -> Int. FIN I/O (DMA)
                 1. Se marca el *marco* como ocupado y ~P=1~
                 2. Se agrega al *TLB*
                 3. Retoma el ciclo de ejecución de la instrucción (se vuelve al principio del proceso de traducción)
              2. Si NO hay *marco* libre => Se elije *marco* victima (Algoritmo + Políticas para reemplazar página)
                 1. Si ~M=0~ de la víctima => En la *TP* de la víctima se cambia ~P=0~ (página ausente, ya no está en MP), se marca el *marco* como libre (en el Header) y se sustituye la página víctima
                 2. Si ~M=1~ de la víctima => se lanza Int. de I/O (de escritura, se guardan los cambios en disco, si se vuelve a cargar la página tiene esos cambios)
              3. Int. FIN de I/O (se desbloquea el proceso)

   *Observaciones:*
   - El proceso se desbloquea cuando se agregó la entrada al *TLB*
   - El *TLB HIT* indica que la página a la que accede está en la TLB (memoria caché) y obtiene su valor
   - Las *instrucciones* (código fuente de un Proceso) hacen referencia a una *página* (una parte del Proceso)

  #+BEGIN_QUOTE
  Interacciones en el proceso de traducción de DL a DF
  
  La MMU interviene cuando
  1. Se busca una página de un proceso en la TLB (al ejecutar una instrucción, porque quizás ya se ejecutó previamente)
  2. Se agrega una entrada en la TLB (para que el próximo acceso a RAM sea más rápido)
  3. Se busca en la TP de un proceso (para saber si tiene la Página que referencia la Instrucción que se quiere ejecutar)
       
  El SO interviene cuando
  1. Al atender una Interrupción por (PF) Page Fault (la página que referencia la instrucción no estaba en RAM, porque P=0)
  2. Al atender una Interrupción de IO (por una operación de lectura, para buscar un marco libre)
  3. Al atender una Interrupción de IO (por una operación de escritura, para cambiar M=1)
  #+END_QUOTE
  
  #+BEGIN_COMMENT
  Sólo se indicaba si un marco estaba ocupado con el *bitmap* ?

  Si TLB MISS + P=0 + está dentro del espacio de direcciones + hay marco libre,
  quien lanza la Interrupcion de IO de lectura?
  #+END_COMMENT
  
  *Referencias:*
  - MMU: Unidad de Manejo de Memoria, nexo entre CPU y RAM, traduce las direcciones para la RAM (de DL a DF)
  - DF: Dirección Física, se calculaba con ~DF = Base + DL~ (mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm) <--------------------------------------
  - TP: Tabla de Página, contiene todas las páginas/porciones/partes de un Proceso y en que Frame de MP está guardado
  - PF: Page Fault, ocurre cuando se quiere acceder a una página que NO está en MP y se debe ir a buscar a SWAP (disco)
  - P: BIT de Presencia (Si P=0 => la página no está en MP, Si P=1 => está en MP)
  - TLB: Memoria Caché de HW para la Tabla de Páginas, para acceso rápido a la información de una Página
  - DMA: Acceso Directo a Memoria, es un Procesador más básico que la CPU, que NO ejecuta instrucciones pero realiza operaciones de E/S
  - CPU: Unidad Central de Procesamiento (Procesador), es el Procesador que ejecuta las instrucciones de los procesos
  - MP: Memoria Principal (RAM), dispositivo de lectura/escritura rápida donde se ejecutan las instrucciones de los procesos
** Políticas de Asignación/Sustitución de Frames (marcos)
*** Políticas de Asignación
**** Fija
     Un *proceso* tiene asignado un número fijo de *frames* (marcos)
**** Dinámica
     Un *proceso* tiene asignado un número variable de *frames* (marcos)
*** Políticas de Sustitución
**** Local
     Se elije de los marcos asignados a ese proceso (scope local)
**** Global
     Se elije de los marcos de cualquier proceso (scope global)
*** Combinación de Politicas (Asignación+Sustitución)
**** Tabla de combinaciones
     |----------+-------+------------|
     |          | LOCAL | GLOBAL     |
     |----------+-------+------------|
     | FIJA     | A     | D (NUNCA!) |
     |----------+-------+------------|
     | DINAMICA | B     | C          |
     |----------+-------+------------|
**** A) Asignacioń Fija y Sustitución Local
     Si un proceso (A) tiene asignado N *marcos* deberá elegir entre esos N marcos cual sustituir
**** B) Asignación Dinámica y Sustitución Local
     Elije y sustituye de los *marcos* que tenga asignados en el momento
**** C) Asignación Dinámica y Sustitución Global
     - Si no tiene suficientes, elije y sustituye del *marco* de otro proceso
     - Le agrega marcos a un proceso (X), y le saca marcos a otro proceso (Y), equiparando..
**** D) Asignación Fija y Sustitución Global
     NO SE PUEDE DAR (porque si sustituyo el marco de un proceso, ya no es una asignación fija)
** [WAITING] Thrashing (Sobrepaginación)
*** Conceptos
    - Los procesos sólo realizan acciones de paginación (swapping), en vez de cumplir su objetivo/tareas
    - Los procesos se bloquean esperando a ser atendidos por la *MMU*, esto provoca que
      1. Caiga el uso de la CPU, porque hay menos procesos ejecutando
      2. Aumente el tiempo de acceso a MP
    - Si un proceso necesita ~N~ páginas durante ~X~ tiempo => necesita que estén en memoria durante ese ~X~ tiempo

    *Observación:*
    - Siempre va a haber (PF) Page Faults porque es *paginación bajo demanda*
    - A mayor cantidad de frames le demos a un proceso => menor es la cant. de PFs
    - A menor cantidad de frames le demos a un proceso => mayor es la cant. de PFs (y NO hará nada productivo, porque siempre le faltará un marco)
*** Soluciones
    - Para el problema (2) -> Reducir el *grado de multiprogramación*
    - Implementar la *localidad temporal* con el *Conjunto de Trabajo*
*** Problema 1 y Problema 2
    #+BEGIN_QUOTE
    Del ejemplo del problema (1):

    Una *asignación fija* (de poco tamaño) con *sustitución local* puede afectar sólo a ese proceso.
    Podría afectar al resto de los procesos, si lo hace es mínimo el impacto porque retrasa el trabajo de los demás procesos
    #+END_QUOTE

    #+BEGIN_QUOTE
    Del ejemplo del problema (2):

    Una *asignación dinámica* con *sustitución global* puede afectar a muchos procesos, NO solo a uno.
    Por tanto puede tener mayor impacto..

    Porque a las páginas de un proceso (en paginación el proceso, está fraccionado en páginas)
    las sacamos de los frames donde están (los frames son espacio en MP, único lugar donde las instrucciones de los procesos pueden ejecutarse)
    por tanto los procesos asociados a esas páginas se bloquean y no pueden ejecutar sus instrucciones
    #+END_QUOTE
*** Problema 1 - Aplicado con Asignación Fija y Sustitución Local 
    #+BEGIN_QUOTE
    Una *asignación fija* (de poco tamaño) con *sustitución local* puede afectar sólo a ese proceso.

    - Podría o no afectar al resto de los procesos
    - Si afectara a alguno de los procesos, a lo mucho retrasa el trabajo del resto de los procesos
    #+END_QUOTE

    Si un porceso tiene pocos *marcos* el *algoritmo de sustitución* se ejecutará a cada rato,
    reemplazando el marco que necesita el proceso y perdiendo otro que también necesitaba,
    haciendo que el proceso NUNCA se ejecute.

    Si un proceso (A) tiene sólo dos marcos asignados y trata de ejecutar dos instrucciones
    
    |-------------+-----------|
    | INSTRUCCIÓN | PROCESO A |
    |-------------+-----------|
    | Operacion_1 | Pagina_20 |
    | Operacion_2 | Pagina_25 |
    |-------------+-----------|
    
    #+BEGIN_QUOTE
    En conclusión, si un proceso tiene menos *frames* (marcos) realizará muchos (PF) *Page Fault* (bloqueandose a cada rato)
    y ejecutará su algoritmo de sustitución de marcos constantemente...

    El algoritmo reemplazará un *marco* (A) existente por otro (B) que necesita,
    pedirá el (A) que había reemplazado y lo reemplazará por el (B) que ya tenía,
    y repetirá el ciclo de sustitución..

    Faltandole siempre un marco para terminar, y nunca terminaría, por tanto tampoco se ejecutaria
    #+END_QUOTE
*** Problema 2 - Aplicado con Asignación Dinámica y Sustitución Global
    #+BEGIN_QUOTE
    Una *Asignación Dinámica* con *Sustitución Global* _puede afectar a MUCHOS procesos_, NO solo a uno.
    
    Por tanto puede tener mayor impacto porque habrán muchos procesos bloqueados
    #+END_QUOTE
    
    - Cuantos más procesos en RAM (grado de multiprogramación) => mayor cant. de (PF) *Page Fault*
      (y.. más procesos robarán marcos de otros procesos, y esos de otros, y asi..)
    - Mayor cant. de *PFs* implíca que
      - Decaiga el uso del CPU (porque ya no hay procesos en *RUNNING*)
      - El SO aumente el *grado de multiprogramación* por no haber procesos en ejecución (a través del *PLP*, si lo tuviese)
      - Aumenta actividad en el *MMU*
    - Mayor cant. de *PFs* implíca
      1. Los procesos comienzan a robar *marcos* de otros
      2. Los procesos necesitan más *marcos* entonces roban a otros (porque otros procesos se los quitan)
      3. Aumenta la cant. de *procesos bloqueados* (porque no pueden terminar su ejecución)
      
    #+BEGIN_COMMENT
    (<<DUDA>>: xq necesita definir otra DL?? tareas de paginación)

    Los procesos roban marcos de otros, porque necesitan alocar sus páginas que necesita usar (acomodar su localidad)
    #+END_COMMENT

    *Referencias:*
    - PLP: Planificador de largo plazo
    - PF: Page fault
    - MMU: Unidad de Manejo de Memoria
*** Conjunto de Trabajo
    - Soluciona el problema de *Trashing* (llevado a la realidad, es la implementación de la Localidad Temporal)
    - Es la implementación de la *localidad temporal* ya que esta es sólo a nivel teórico
    - La *suma de los tamaños de los trabajos de los procesos* debe ser menor o igual a la *cant. de marcos*
    - _Cada cierto tiempo se vuelve a analizar esa sumatoria, y comparar con la cant. de marcos_
*** Localidad Temporal
    - Soluciona el problema de *Trashing* (sólo a nivel teórico)
    - Es el conjunto de paginas que un proceso tiene por ~X~ tiempo (en memoria)
    - Soluciona el problema de *Trashing* <=si y sólo si=> Si el proceso tiene los *frames* necesarios para ajustar su *localidad*
      
    #+BEGIN_QUOTE
    Si le das menos *frames* vuelve a ocurrir el problema de *Trashing*
    
    Si le das más *frames* le estamos quitando los *frames* que puede necesitar otro proceso
    #+END_QUOTE
*** Ejemplo
    Si tenemos como datos
    1. Frames para procesos: 8
    2. Tamaño ventana de trabajo: 5 últimas referencias

    #+name: proceso-1
    |---+---+---+---+----+---+---+---+---+---+---+---+---+---+---+----+---|
    | 3 | 4 | 4 | 3 |  4 | 4 | 3 | 3 | 4 | 1 | 4 | 3 | 5 | 3 | 6 |  4 | 6 |
    |---+---+---+---+----+---+---+---+---+---+---+---+---+---+---+----+---|
    |   |   |   |   | t1 |   |   |   |   |   |   |   |   |   |   | t2 |   |
     
    #+name: proceso-2
    |---+---+---+---+----+---+---+---+---+---+---+---+---+---+----+---|
    | 1 | 1 | 1 | 1 |  3 | 2 | 3 | 3 | 1 | 6 | 6 | 5 | 3 | 7 |  4 | 6 |
    |---+---+---+---+----+---+---+---+---+---+---+---+---+---+----+---|
    |   |   |   |   | t1 |   |   |   |   |   |   |   |   |   | t2 |   |

    #+name: proceso-3
    |---+---+---+---+---+----+---+---+---+---+---+---+---+---+---+----+---|
    | 8 | 4 | 7 | 7 | 8 |  4 | 3 | 3 | 4 | 8 | 4 | 3 | 8 | 3 | 8 |  4 | 6 |
    |---+---+---+---+---+----+---+---+---+---+---+---+---+---+---+----+---|
    |   |   |   |   |   | t1 |   |   |   |   |   |   |   |   |   | t2 |   |

    #+BEGIN_QUOTE
    *Situación (A):*
    Del instante ~t1~ tenemos:
    - CT(P1) = 3,4 => Tamaño_CT = 2
    - CT(P2) = 1,3 => Tamaño_CT = 2
    - CT(P3) = 8,4,7 => Tamaño_CT = 3
     
    Si sumamos el conjunto de trabajos de los procesos P1,P2,P3
    Sumatoria_CT(P1,P2,P3) = 2+2+3 = 7
    y.. 7 < 8 (es menor a la cant. de marcos para procesos)
    entonces OK..! Se cumple 
    #+END_QUOTE

    #+BEGIN_QUOTE
    *Situación (B):*
    Del instante ~t2~ tenemos:
    - CT(P1) = 6,3,5,4 => Tamaño_CT = 4
    - CT(P2) = 7,3,5,6 => Tamaño_CT = 4
    - CT(P3) = 8,3,4 => Tamaño_CT = 3

    SI hacemos la sumatoria, nos da 11 > 8 (es mayor a la cant. de marcos que teniamos asignados)
    entonces seguramente ocurra el problema de *Sobrepaginación*,
    una posible solución sería suspender alguno de los procesos al menos hasta que baje la necesidad de frames
    #+END_QUOTE
* [DOING] Algoritmos de Sustitución de Páginas
** Operación de carga/descarga de paginas
   Por cada *PF* lo que ocurre es
   1. Una operación de carga de página: _se lee la página faltante_, y se carga en *MP*
   2. Una operación de descarga: _se escribe el valor del frame_ que es victima en *SWAP* (disco)

   La segunda podría no ocurrir...
** Análisis y Comparación en los Algoritmos
   En cada algoritmo
    - Se analizará una *secuencia de referencias*
    - Se comparará la canti. de *PFs* que genera cada *referencia*
      <<DUDA>>: Las referencias son los marcos que apuntan a las páginas?
    - Lo más importante de la secuencia serán los *número de página*
      <<DUDA>>: Porque?
** Anomalía de Belady
   - Mayor cant. de *frames* (/asignar más recursos/) => implíca mayor cant. de (PF) *Page Faults* (/se comporta peor/)
   - Ocurre en algunos algoritmos ante determinadas secuencias de *referencias*

   #+BEGIN_QUOTE
   Por lo general a mayor cant. de *frames* a una secuencia
   se tiende a generar igual o menor cant. de *PFs*
   pero puede en ciertos casos darse la *Anomalía de Belady*
   #+END_QUOTE

   #+BEGIN_COMMENT
   <<DUDA>>: secuencia de que? de asignación?
   #+END_COMMENT
** Tips Resolución de Ejercicios
   1. Un conjunto de páginas que necesita cada proceso
   2. Cuando no hay páginas cargadas, se cargarán en el primer *frame* libre
   3. Cuando haya una *página* que NO esté cargada en un *frame* (osea, NO está en MP)
      1. Ocurrirá *Page Fault* (PF)
      2. Habrá un acceso a *SWAP* (disco) para escribir/cargarla la página a MP (/en un frame/) <-- _operación de escritura_
   4. En las primeras *referencias* no habrá sustitución, ocurrirá *Page Fault* (PF) porque no está la página y se cargará
   5. Se realiza una _operación de escritura_ en *SWAP* (disco)
      1. Cada vez que se carga una página en un *frame*
      2. Cada vez que haya un *Page Fault* (PF)
   6. Cuando se carga una página en *modo de escritura* (M=1) y se quiere sobreescribir por otra (requiere 2 accesos a disco)
      1. Se debe escribir en la página que estaba en modo escritura en *SWAP* (disco)
      2. Luego escribir la nueva página nueva en el *frame* (en la *MP*)
      
   #+BEGIN_COMMENT
   <<DUDA>>: Cada vez que se carga en modo escritura, es modificado=1 ?
   
   <<DUDA>>: Cómo sería el 6.2 ?
   #+END_COMMENT
* [DOING] Tipos de Algoritmos de Sustitución de Páginas
** Algoritmo FIFO
*** Conceptos
    - Se evalúa el *tiempo de carga*
*** Criterio para seleccionar víctima
    - Elige como víctima a la *página* que está cargada en MP hace más tiempo
*** Implementación
    - Guardando en que instante de tiempo se cargó la *página* a MP y eligiendo la de menor valor
    - Cola FIFO, eligiendo la *página* que primero se agregó a la cola de FIFO
*** Desventajas
    - Sufre la *Anomalía de Belady*
*** Ejemplo
    Si tenemos la siguiente secuencia de páginas

    |---------------------------+-----+-----+-----+-----+------+-----+-----+-----+-----+-----+-----+-----+-------|
    | Secuencia de Páginas      |   2 |  3' |   2 |   1 | ~5'~ |   2 |  4' |   5 |   3 |  2' |   5 |   2 | TOTAL |
    |---------------------------+-----+-----+-----+-----+------+-----+-----+-----+-----+-----+-----+-----+-------|
    | 1º Frame (marco en MP)    | ->2 | ->2 | ->2 | ->2 | ~5~  |   5 | ->5 | ->5 |   3 |   3 |   3 |   3 |       |
    | 2º Frame (marco en MP)    |     |   3 |   3 |   3 | ->3  | ~2~ |   2 |   2 | ->2 | ->2 | ~5~ |   5 |       |
    | 3º Frame (marco en MP)    |     |     |     |   1 | 1    | ->1 |   4 |   4 |   4 |   4 | ->4 | ~2~ |       |
    |---------------------------+-----+-----+-----+-----+------+-----+-----+-----+-----+-----+-----+-----+-------|
    | Page Faults               |   1 |   1 |   0 |   1 | 1    |   1 |   1 |   0 |   1 |   0 |   1 |   1 |     9 |
    |---------------------------+-----+-----+-----+-----+------+-----+-----+-----+-----+-----+-----+-----+-------|
    | Acceso a SWAP (disco)     |   1 |   1 |   0 |   1 | 1    |   2 |   1 |   0 |   2 |   0 |   2 |   2 |    13 |
    |---------------------------+-----+-----+-----+-----+------+-----+-----+-----+-----+-----+-----+-----+-------|
    | Operación de Lectura en   | p=2 | p=3 |     | p=1 | p=5  | p=2 | p=4 |     | p=3 |     | p=5 | p=2 |       |
    |---------------------------+-----+-----+-----+-----+------+-----+-----+-----+-----+-----+-----+-----+-------|
    | Operación de Escritura en |     |     |     |     |      | p=3 |     |     | p=5 |     | p=2 | p=4 |       |
    |---------------------------+-----+-----+-----+-----+------+-----+-----+-----+-----+-----+-----+-----+-------|

    #+BEGIN_COMMENT
    Cada vez que se accede en modo escritura, se modifica el BIT de modificado
    agregar ḿás detalles de esto...
    #+END_COMMENT
    
    *Observaciones:*
    - Las secuencias que tengan el apóstrofe, son páginas que se acceden en *modo de escritura* esto implíca
      1. modificar el *BIT de modificado*
      2. habrá una *operación de escritura* osea un acceso a disco (por lo anterior del BIT)
    - Las páginas marcadas con ~->~ indican que son víctimas a ser sustituídas (según el algoritmo)
    - Siempre que ocurra un *Page Fault* (PF) implíca una *operación de lectura* porque
      1. Hay que traerse esa página de SWAP (disco)
      2. Para luego cargarla a MP (memoria)
    - Siempre que hay una *pagina* en *modo escritura* y se debe sustituir, habrá una operación de disco adicional
      para guardar el cambio
    
    #+BEGIN_QUOTE
    Desde la posicion=1 ... posicion=4, es sólo *Paginación bajo demanda*,
    no estamos aplicando ningún *Algoritmo de Sustitución*
    
    En la posicion=1 de la secuencia
    1. Intentamos acceder a la página=2
    2. Cómo no está cargada en memoria (no está en ningun frame) => ocurre *Page Fault* (PF)
    3. Se hace la lectura de la pagina=2 por tanto accede a SWAP (disco)
    4. Se asigna la página=2 al frame=1 (porque era el primer frame disponible)

    En la posicion=3 de la secuencia
    1. Intentamos acceder nuevamente a la pagina=2
    2. Como ya está cargada en memoria (está en el frame=2) => NO ocurre *Page Fault* (PF) + NO hay acceso a SWAP
    #+END_QUOTE

    #+BEGIN_QUOTE
    Desde el principio ya se marca a la *página 2* como víctima con el ~->~
    será la primera en ser sustituída.
    
    En la posicion=5 de la secuencia, comienza el *Algoritmo de Sustitución* (FIFO)
    1. Se elige sustituir la *página 2* que está en el frame=1, porque es la que estuvo más tiempo en la cola de FIFO,
       fue el primero en ser cargado a memoria. Entonces la reemplazamos por la *página 5*
    2. Marcamos a la *página 3* que está en el frame=2 como próxima víctima,
       porque fue la segunda en ser cargada a memoria.
    #+END_QUOTE
** Algoritmo OPTIMO
*** Conceptos
    - Intenta minimizar la cantidad de *Page Fault* (PF)
      (ese PF implíca un acceso a disco/swap, que es una operación de lectura para traerse de disco la página que no está en MP)
*** Criterio para seleccionar víctima
    - Se reemplazará (en los *frames* de MP) a la página que *referenciamos* (usaremos) más lejos en el futuro
      (osea que luego no se referencia, ó que está como último, respecto de la posición actual en la secuencia)
      
    #+BEGIN_QUOTE
    Si tenemos la siguiente secuencia de páginas: 7,2,3,(4),5,2, ~1~ ,4,1
    Si en esa secuencia estamos parados en el 4, elegirá al 1 (porque es el más lejano al 4)
    
    Si tenemos esta otra secuencia de páginas: 7,(2),3,4,5, ~1~
    Si en esa secuencia estamos parados en el 2, elegirá al 1 (porque es el más lejano al 2)
    #+END_QUOTE
*** Ejemplo
    Si tenemos la siguiente secuencia de páginas

    |---------------------------+-----+-----+---+-----+------+---+-----+---+---+-----+---+---+-------|
    | Secuencia de Páginas      |   2 |  3' | 2 |   1 | ~5'~ | 2 |  4' | 5 | 3 |  2' | 5 | 2 | TOTAL |
    |---------------------------+-----+-----+---+-----+------+---+-----+---+---+-----+---+---+-------|
    | 1º Frame (marco en MP)    |   2 |   2 | 2 |   2 |    2 | 2 | ~4~ | 4 | 4 |   4 | 4 | 4 |       |
    | 2º Frame (marco en MP)    |     |   3 | 3 |   3 |    3 | 3 |   3 | 3 | 3 | ~2~ | 2 | 2 |       |
    | 3º Frame (marco en MP)    |     |     |   |   1 |  ~5~ | 5 |   5 | 5 | 5 |   5 | 5 | 5 |       |
    |---------------------------+-----+-----+---+-----+------+---+-----+---+---+-----+---+---+-------|
    | PFs                       |   1 |   1 | 0 |   1 |    1 | 0 |   1 | 0 | 0 |   1 | 0 | 0 |  6    |
    |---------------------------+-----+-----+---+-----+------+---+-----+---+---+-----+---+---+-------|
    | Acceso a SWAP (disco)     |   1 |   1 | 0 |   1 |    1 | 0 |   1 | 0 | 0 |   2 | 0 | 0 |  7    |
    |---------------------------+-----+-----+---+-----+------+---+-----+---+---+-----+---+---+-------|
    | Operación de Lectura en   | p=2 | p=3 |   | p=1 |  p=5 |   | p=4 |   |   | p=2 |   |   |       |
    |---------------------------+-----+-----+---+-----+------+---+-----+---+---+-----+---+---+-------|
    | Operación de Escritura en |     |     |   |     |      |   |     |   |   | p=3 |   |   |       |
    |---------------------------+-----+-----+---+-----+------+---+-----+---+---+-----+---+---+-------|

    *Observación:*
    - Las secuencias que tengan el apóstrofe, son páginas que están en *modo de escritura*
    
    #+BEGIN_QUOTE
    Desde la posicion=1 ... posicion=4, es sólo *Paginación bajo demanda*,
    no estamos aplicando ningún *Algoritmo de Sustitución*
    
    En la posicion=1 de la secuencia
    1. Intentamos acceder a la página=2
    2. Cómo no está cargada en memoria (no está en ningun frame) => ocurre *Page Fault* (PF)
    3. Se hace la lectura de la pagina=2 por tanto accede a SWAP (disco)
    4. Se asigna la página=2 al frame=1 (porque era el primer frame disponible)

    En la posicion=3 de la secuencia
    1. Intentamos acceder nuevamente a la pagina=2
    2. Como ya está cargada en memoria (está en el frame=2) => NO ocurre *Page Fault* (PF) + NO hay acceso a SWAP
    #+END_QUOTE
    
    #+BEGIN_QUOTE
    En la posicion=5 de la secuencia, comienza el *Algoritmo de Sustitución*

    Cuando evaluamos la página=5 (que está en *modo de escritura*)
    al decidir que *página* reemplazar (entre la 2,3,1) se elije la ~1~ (que estaba en el *3º Frame*)
    porque la ~1~ no está cerca de la posición actual, respecto a las próximas páginas que le siguen 2,3,4,2,..
    
    Si estuviera al final, también se elegiría al ~1~, porque estaría lejos..
    y si estuviera luego del ~4~ también, porque aún sería la página las lejana respecto de la ~5~
    #+END_QUOTE
*** Ventajas
    - NO sufre la *Anomalía de Belady*
*** Desventajas
    - NO se puede implementar, al igual que el *SJF* de planificación que no se podía estimar
** Algoritmo Least Recent use (LRU)
*** Conceptos
    - Se evalúa el *tiempo de acceso* (que puede ir variando)
    - Refiere a la página que usé hace más tiempo (si la usé hace mucho tiempo, en el futuro seguramente tampoco la use tanto)
    - Utiliza el pasado reciente como una aprox. del futuro
*** Criterio para seleccionar víctima
    - Elige a la *página* menos recientemente utilizada (hace más tiempo que no se referencia)
*** Implementación
**** Con Pila
     - Una pila de los números de páginas
     - Con cada referencia se coloca la pag. superior (asi actúa una pila, se apila/encimando, y arriba va el más reciente)
     - Se elige la página de la parte inferior (porque sería el que se usó antes)
**** Con un puntero contador
     - Se elige el que tiene menor valor
     - Crear un puntero al menor

     #+BEGIN_COMMENT
     <<DUDA>>: Pero el menor no sería el más reciente?
     Rta: Si, pero el más reciente en el pasado, en el ejemplo hago una demostración.
     #+END_COMMENT
*** Ventajas
    - NO sufre la *Anomalía de Belady*
*** Desventajas
    - Es costoso a nivel de HW
    - A nivel de SW no se podría implementar, porque sería muy lento

    #+BEGIN_COMMENT
    <<DUDA>>: porque es costo a nivel de hw? por la estimación de tiempo?
    
    <<DUDA>>: sería lento a nivel de SW, tanto si elegimos la pila o el puntero contador?
    #+END_COMMENT
*** Ejemplo
    #+name: algoritmo-lru
    |---------------------------+-----+-----+----+-----+------+----+------+----+------+------+----+----+-------|
    | Secuencia de Páginas      |   2 |  3' |  2 |   1 | ~5'~ |  2 | 4'   |  5 | 3    | 2'   |  5 |  2 | TOTAL |
    |---------------------------+-----+-----+----+-----+------+----+------+----+------+------+----+----+-------|
    | 1º Frame (marco en MP)    |   2 |   2 |  2 |   2 |    2 |  2 | 2    |  2 | ~3'~ | 3'   | 3' | 3' |       |
    | 2º Frame (marco en MP)    |     |  3' | 3' |  3' | ~5'~ | 5' | 5'   | 5' | 5'   | 5'   | 5' | 5' |       |
    | 3º Frame (marco en MP)    |     |     |    |   1 |    1 |  1 | ~4'~ | 4' | 4'   | ~2'~ | 2' | 2' |       |
    |---------------------------+-----+-----+----+-----+------+----+------+----+------+------+----+----+-------|
    | Page Fault                |   1 |   1 |  0 |   1 |    1 |  0 | 1    |  0 | 1    | 1    |  0 |  0 |     7 |
    |---------------------------+-----+-----+----+-----+------+----+------+----+------+------+----+----+-------|
    | Acceso a SWAP (disco)     |   1 |   1 |  0 |   1 |    2 |  0 | 1    |  0 | 1    | 2    |  0 |  0 |     9 |
    |---------------------------+-----+-----+----+-----+------+----+------+----+------+------+----+----+-------|
    | Operación de Lectura en   | p=2 | p=3 |    | p=1 |  p=5 |    | p=4  |    | p=3  | p=2  |    |    |       |
    |---------------------------+-----+-----+----+-----+------+----+------+----+------+------+----+----+-------|
    | Operación de Escritura en |     |     |    |     |  p=3 |    |      |    |      | p=4  |    |    |       |
    |---------------------------+-----+-----+----+-----+------+----+------+----+------+------+----+----+-------|

    #+BEGIN_QUOTE
    *Situación A:* En la posición=5 de la secuencia, cuando se accede a ~5'~ ocurren 2 accesos a disco porque
    1. Por *LEER de swap* por causa del *Page Fault* (PF) ya que esa página no estaba en MP
       (/la pagina ~5'~ la tengo que leer de *SWAP* (disco) para luego pasarla al *frame* de *MP* (RAM))
    2. Por *ESCRIBIR en swap*
       (porque la pag. ~3'~ que estoy reemplazando estaba modificada ~m=1~ (es decir tenía el BIT de modificado de TP en 1),
       y antes de reeemplazar se debe escribir en SWAP para no perder esos cambios)
    #+END_QUOTE

    #+BEGIN_QUOTE
    Un ejemplo de _como se podría implementar con un contador_, sería tener asociado a cada página un contador.
    Mientras se avanza en la secuencia de acceso de las páginas, se incrementa en 1 la página,
    la de menor valor sería la más reciente del pasado

    Por ejemplo hasta el tiempo=6 de la secuencia dada {2,3',2,1,5',2} tendríamos
    
    | Página | valor contador asociado |
    |--------+-------------------------|
    |      2 |                       6 |
    |      5 |                       5 |
    |      1 |                       4 |

    La página 1 sería la más reciente en el pasado, su valor es menor
    #+END_QUOTE
** Algoritmo Clock (ó de segunda oportunidad)
*** Conceptos
    - Basado en FIFO, se aproxima al *LRU*
    - Se aplica el algoritmo sólo cuando se debe reemplazar una página, hasta tanto se aplica FIFO (al principio, cuando hay frames libres)
    - Tiene menos ~OVERHEAD~ que el *LRU*
*** Criterio para seleccionar víctima
    - Si ~U=0~ => Encontró su víctima y sustituye esa página y avanza el puntero al sig. frame
    - Si ~PF=0~ => NO elige a nadie, y avanza al sig. número de página de la secuencia
    - Desempata por *tiempo de carga* (como el de FIFO) <- el que menor TC tenga
*** Puntero
    - Tiene un *puntero* que indica cual es la siguiente *página* víctima a ser sustituída
    - Cambia la referencia (a una página que está un frame) sólo cuando se aplica el algoritmo de sustitución
    - Se compara el puntero 

    #+BEGIN_COMMENT
    <<DUDA>>: la cola es circular??? Osea que vuelve al primer frame?
    cola circular, se selecciona a la siguiente victima
    Rta: Si, va evaluando cada frame y si es necesario vuelve al principio, al primer frame
    #+END_COMMENT
*** Bit de uso
    - Trata de aproximar el algoritmo
    - Se modifica sólo cuando hay que sustituir páginas (se aplica el algoritmo)
    - Se habilita cada vez que se acceda a la página, cuando se acceda de cualquier manera (lectura/escritura)
    - Las páginas que use de nuevo se les da una 2da oportunidad :)
    - Comportamiento del algoritmo según el valor del *Bit de uso*
      1) Si ~U=0~ => *Encontró su víctima* => _SUSTITUYE esa página_ y avanza el *puntero* al sig. frame
      2) Si ~U=1~ => *Le da otra oportunidad* => _NO la sustituye_, pero modifica ~U=0~ y avanza el *puntero* al sig. frame
         (si la *página* del sig. *frame* tiene ~U=1~ => lo pasa a 0 y avanza el puntero al sig frame, y asi..)

    #+BEGIN_COMMENT
    El *bit de uso* se denota con la ~U~ pudiendo variar su valor
    - Si ~U=1~ (habilitado) la página fue usada, se accedió recientemente
    - Si ~U=0~ (deshabilitado) la página no fue usada aún
    #+END_COMMENT
*** Ejemplo
    *Observaciones:*
    - Siempre que cargamos una nueva página, va a tener el bit de uso activado osea ~u=1~
    - Si el cursor apunta a una página N^⁰ con ~u=0~ y en la secuencia se va a cargar esa página N,
      entonces se habilita el *bit de uso* pasando a ~u=1~ y avanzando el cursor y analizar el resto
    
    |---------------------------+-------+-------+-------+-------+--------+-------+-------+-------+-------+-------+-------+-------+-------|
    | Secuencia de Páginas      |     2 | 3'    |     2 | 1     | 5'     | 2     | 4'    | 5     | 3     | 2'    | 5     | 2     | TOTAL |
    |---------------------------+-------+-------+-------+-------+--------+-------+-------+-------+-------+-------+-------+-------+-------|
    | Bits                      |   P U | P U   |   P U | P U   | P U    | P U   | P U   | P U   | P U   | P U   | P U   | P U   |       |
    |---------------------------+-------+-------+-------+-------+--------+-------+-------+-------+-------+-------+-------+-------+-------|
    | 1º Frame (marco en MP)    | ->2^¹ | ->2^¹ | ->2^¹ | ->2^¹ | ~5^¹~  | 5^¹   | ->5^¹ | ->5^¹ | ~3^¹~ | 3^¹   | ->3^¹ | ->3^¹ |       |
    | 2º Frame (marco en MP)    |       | 3'^¹  |  3'^¹ | 3'^¹  | ->3'^⁰ | ~2^¹~ | 2^¹   | 2^¹   | ->2^⁰ | ->2^¹ | 2^⁰   | 2^¹   |       |
    | 3º Frame (marco en MP)    |       |       |       | 1^¹   | 1^⁰    | ->1^⁰ | ~4^¹~ | 4^¹   | 4^⁰   | 4^⁰   | ~5^¹~ | 5^¹   |       |
    |---------------------------+-------+-------+-------+-------+--------+-------+-------+-------+-------+-------+-------+-------+-------|
    | PFs                       |     1 | 1     |     0 | 1     | 1      | 1     | 1     | 0     | 1     | 0     | 1     | 0     |     8 |
    |---------------------------+-------+-------+-------+-------+--------+-------+-------+-------+-------+-------+-------+-------+-------|
    | Acceso a SWAP (disco)     |     1 | 1     |     0 | 1     | 1      | 2     | 1     | 0     | 2     | 0     | 2     | 0     |    11 |
    |---------------------------+-------+-------+-------+-------+--------+-------+-------+-------+-------+-------+-------+-------+-------|
    | Operación de Lectura en   |   p=2 | p=3   |       | p=1   | p=5    | p=2   | p=4   |       | p=3   |       | p=5   |       |       |
    |---------------------------+-------+-------+-------+-------+--------+-------+-------+-------+-------+-------+-------+-------+-------|
    | Operación de Escritura en |       |       |       |       |        | p=3   |       |       | p=5   |       | p=4   |       |       |
    |---------------------------+-------+-------+-------+-------+--------+-------+-------+-------+-------+-------+-------+-------+-------|
    #+TBLFM: @6$14=vsum($2..$-1)::@7$14=vsum($2..$-1)

    *Referencias:*
    - En la 2da fila Bits
      1. P: página
      2. U: BIT de Uso
    - Las páginas que estén marcadas así ~numero~ indica como va avanzar el *puntero* entre los *frames*
    - Las potencias en ^¹ se refieren a bit_de_uso=1 (habilitado)
    - Las potencias en ^⁰ se refieren a bit_de_uso=0 (deshabilitado)
      
    #+BEGIN_QUOTE
    Un ejemplo de que ocurrió entre la posicion=4 y posicion=5 de la secuencia de páginas
    
    En la posicion=5 de la secuencia de páginas, inicia el algoritmo de sustitución
    1. Observamos que el puntero en estaba apuntando a la página=2 en el frame=1 en la posicion anterior (->2^¹)
    2. En el frame 1, modifica el BIT de uso de la página 2 a ~u=0~, y avanza el cursor al siguiente frame (->3'^¹)
    3. En el frame 2, modifica el BIT de uso de la página 3 a ~u=0~  y avanza el cursor al siguiente frame (->1^¹)
    4. En el frame 3, modifica el BIT de uso de la página 1 a ~u=0~ y avanza el cursor al siguiente frame
       pero.. como no hay más frames y se comporta como una *cola circular* coloca el cursor al *frame 1*
       
    En los pasos (1) (2) (3) (4) el algoritmo avanzó en cada frame, y actualizó el bit de uso en cada página, quedando así
    | 1º FRAME | ->2^⁰ |
    | 2º FRAME | 3^⁰   |
    | 3º FRAME | 1^⁰   |
    
    5. El algoritmo elige la página 2 es la víctima, porque el puntero volvió a la página 2, y su bit de uso es ~u=0~
    6. El algoritmo sustituye la *página 2* por la *página 5* y avanza el cursor al siguiente frame quedando
    |          | 5'    |
    |----------+-------|
    | 1º FRAME | 5^¹   |
    | 2º FRAME | ->3^⁰ |
    | 3º FRAME | 1^⁰   |

    El bit de uso de la página 3 y página 1 quedó en ~u=0~ porque el algoritmo recorrió cada frame avanzando el puntero,
    cuando el bit de uso era 1.
    Bit de uso es 1? Ok lo cambio a 0 y avanzo el cursor a la página del siguiente frame,
    Bit de uso es 1? Ok lo cambio a 0 y avanzo el cursor a la página del siguiente frame,
    y asi.. pudiendo volver hasta el principio si todas las paginas tenian el bit de uso en 1
    #+END_QUOTE

    #+BEGIN_QUOTE
    En la posicion=9 de la secuencia de páginas, ocurre lo mismo que en la posicion=5..

    1. Analizamos la posición anterior, el puntero apunta a la *página 5* y éste tiene bit de uso ~u=1~
       entonces lo modifica a ~u=0~, avanza el puntero a la página del siguiente frame (frame=2)
    2. El puntero apunta a la página 2, tiene bit de uso ~u=1~ lo modifica a ~u=0~ y avanza el puntero al sig. frame
    3. Se repite lo mismo, el puntero apunta a la página 3, tiene bit de uso ~u=1~ lo modifica a ~u=0~ y avanza el puntero al sig. frame
       como es una cola circular, vuelve primer frame
    4. En este momento todas las páginas quedaron con el bit de uso ~u=0~,
       como el puntero apunta a la *página 5* y su bit de uso es ~u=0~ entonces es víctima,
       entonces se sustituye la *pagina 5* por la *página 3*

    En resumen, todas las páginas se les modificó el bit de uso a ~u=0~ porque el puntero fue avanzando frame por frame
    y las páginas tenian el bit de uso en 1, cuando el puntero volvió al primer frame que tenia la *página 5* (la victima)
    la sustituyó por la *pagina 3*
    
    Nota 1: Como se carga la página 3, ésta va a tener el bit de uso en ~u=1~
    Nota 2: Como la página 5 estaba modificada xq tenía el apóstrofe de que estaba en *modo de escritura*,
    se debe hacer un acceso a disco para guardar los cambios (operación de escritura)
    #+END_QUOTE

    #+BEGIN_QUOTE
    En la posicion=9,10,11 la *página 2* cambió el bit de uso de ~u=0~ a ~u=1~ y luego a ~u=0~
    
    en la posicion=10
    1. se accedía la página ~2'~ que ya estaba en memoria (en la posicion anterior)
       pero tenía el *bit de uso* desactivado osea ~u=0~ entonces sólo se volvió a activar
       cambiandolo a ~u=0~ quedando (->2^¹)

    
    en la posicion=11
    1. se accedía a la *pagina 5* como el puntero apuntaba a la *página 2* (->2^¹)
       y tenía el *bit de uso* en ~u=1~ se lo cambio a ~u=0~ para darle otra oportunidad,
    2. avanzó el cursor al siguiente frame que tenía la *pagina 4* (->4^⁰)
       pero como tenía el *bit de uso* en ~u=0~ era víctima, y sustituyó la *pagina 4* por la *pagina 5*
    #+END_QUOTE
    
    #+BEGIN_COMMENT
    *Caso (A): Cuando el puntero avanza, cuando se cambia el BIT de Uso y cuando se ejecuta el algoritmo*
    En la posición=4 de la secuencia observamos la página ~1~ 
    1. Al ingresar el número de página en el 3º Frame, ya puede iniciar el algoritmo
    2. El puntero estaba en el 1º frame que contiene al ~2~ y este tiene ~BIT_uso=1~, 
       entonces lo modifica a cero ~bit_uso=0~ y avanza el puntero al 2º frame
    3. El puntero está en el 2º frame que contiene a ~3'~ este tiene ~bit_uso=1~
       lo cambia a cero y avanza el puntero al 3º frame
    4. El puntero está en el 3º frame que contiene a ~1~ este también tiene ~bit_uso=1~
       lo modifica a cero y vuelve a apuntar al 1º frame que contiene al ~2~
    5. El puntero está en el 1º frame que contiene a la pag. ~2~
       pero.. como su ~bit_uso=0~ aplicará la sustitución de página por ~5~
       y cambia el ~bit_uso=1~ y avanza el puntero al 2º frame
    #+END_COMMENT

    #+BEGIN_COMMENT
    validar
    
    *Caso (B): Dos accesos a SWAP (disco)*
    En la posicion=6 de la secuencia notamos que en la página ~2~ que está seguido del ~5~
    hay dos accesos a disco (swap) porque
    1. El frame que se sustituye es el 2º y tiene a la página ~3~ que estaba modificada
       osea tenia bit_modificado=1, por tanto se debe guardar el valor de esa página ~3~
       en SWAP para no perder los datos(primer acceso a disco). Y luego escribir en SWAP
       por el propio PF (xq no estaba en el espacio de direcciones del proceso) la página ~2~ 
       en el mismo 2º frame (2do acceso a disco)
    #+END_COMMENT
** Algoritmo Clock Modificado
*** Conceptos
*** Seleccionar Victima
    - Se busca al de mayor prioridad, la página que tenga el par ordenado ~(0,0)~ es decir ~m=0~ y ~u=0~ (porque se ahorra el no tener que bajarla a disco)
    - Se desempata por *bit de modificado* prefiriendo que sea ~m=0~
*** Prioridad
    - El *bit de uso* ~u~ tiene más prioridad que el *bit de modificado* ~m~ porque
      - porque fue recientemente utilizado, y va a ser utilizado a futuro
      - si lo reemplazara podría ocurrir un *Page Fault* (PF)
    - Como la prioridad está marcada por el *bit de uso*
      1. ~(u=0, m=0)~ <- mayor prioridad (se evita acceso a disco porque m=0, y sólo modifica el bit de uso a u=1)
      2. ~(u=0, m=1)~
      3. ~(u=1, m=1)~ <- menor prioridad, porque ~u != 0~ (implíca bajar la página a disco, porque m=1 tiene cambios que deben guardarse antes de reemplazar la página)
*** Bit de Modificado y Bit de Uso
    #+BEGIN_QUOTE
    El *bit de modificado* se desactiva cuando se bajan los cambios a disco
    es decir ~m=1~ a ~m=0~

    Por ejemplo si la página N' voy a reemplazarla por otra pagina Y,
    como esa pagina figura con apóstrofe que indica que tiene *modo de escritura*
    entonces la vamos a pasar a disco porque se deben salvar los cambios
    antes de sustituirla por otra página
    #+END_QUOTE

    #+BEGIN_QUOTE
    El *bit de uso* ~u~ de una pagina N, NO se va a modificar si antes de esa página N
    encontró una víctima para sustituir por la página a la que se quiere acceder
    y que no se encuentran en MP

    Por ejemplo si tenemos la siguiente secuencia de páginas
    |         | 2         | 4'          |
    |---------+-----------+-------------|
    | frame 2 | ->3^(0,1) | 4^(1,1)     |
    | frame 3 | ~2^(1,0)~ | ~->2^(1,0)~ |

    entre la posicion=1,2 de la secuencia.. la *página 2* no se modificó el *bit de uso* ~u~
    quedó en ~u=1~ porque la primera víctima era la *pagina 3* que tenía ~(u=0,m=1)~
    por tener más prioridad (0,1) que (1,0) por la primera componente que es el *bit de uso*

    por tanto se sustituye la *página 3* por la que se quiere acceder (la página 4)
    y se avanza el cursor a la página del siguiente frame (la página 2)
    #+END_QUOTE
*** Ejemplo

    | Secuencia de páginas      |         2 | 3'        |         2 | 1         | 5'        | 2         | 4'        | 5         | 3         | 2'         | 5         | 2         | TOTAL |
    |---------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+------------+-----------+-----------+-------|
    | BITS                      |     P U M | P U M     |     P U M | P U M     | P U M     | P U M     | P U M     | P U M     | P U M     | P U M      | P U M     | P U M     |       |
    |---------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+------------+-----------+-----------+-------|
    | FRAME 1                   | ->2^(1,0) | ->2^(1,0) | ->2^(1,0) | ->2^(1,0) | ~5^(1,1)~ | ->5^(1,1) | 5^(0,1)   | ~5^(1,1)~ | ->5^(0,1) | ~2'^(1,1)~ | 2'^(1,1)  | 2'^(1,1)  |       |
    | FRAME 2                   |           | 3^(1,1)   |   3^(1,1) | 3^(1,1)   | ->3^(0,1) | 3^(0,1)   | ~4^(1,1)~ | 4^(1,1)   | 4^(0,1)   | ->4^(0,1)  | ~5^(1,0)~ | 5^(1,0)   |       |
    | FRAME 3                   |           |           |           | 1^(1,0)   | 1^(0,0)   | ~2^(1,0)~ | ->2^(1,0) | ->2^(1,0) | ~3^(1,0)~ | 3^(1,0)    | ->3^(1,0) | ->3^(1,0) |       |
    |---------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+------------+-----------+-----------+-------|
    | Page Faults               |         1 | 1         |         0 | 1         | 1         | 1         | 1         | 0         | 1         | 1          | 1         | 0         |     9 |
    |---------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+------------+-----------+-----------+-------|
    | Acceso a SWAP (disco)     |         1 | 1         |         0 | 1         | 1         | 1         | 2         | 0         | 1         | 2          | 2         | 0         |    12 |
    |---------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+------------+-----------+-----------+-------|
    | Operación de Lectura en   |       p=2 | p=3       |           | p=1       | p=5       | p=2       | p=4       |           | p=3       | p=2        | p=5       |           |       |
    |---------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+------------+-----------+-----------+-------|
    | Operación de Escritura en |           |           |           |           |           |           | p=3       |           |           | p=5        | p=4       |           |       |
    |---------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+------------+-----------+-----------+-------|
    #+TBLFM: @6$14=vsum($2..$-1)::@7$14=vsum($2..$-1)

    #+BEGIN_QUOTE
    Entre la posicion=4,5 el cursor pasa por cada frame, modificando el *bit de uso* ~u~
    de las *paginas 2,3,1* a ~u=0~, quedando el cursor de nuevo en el primer frame
    y siendo ahí donde sustituye la página por la *pagina 5*
    
    y avanzando el cursor al siguiente frame (2) que tiene la *pagina 3*
    #+END_QUOTE

    #+BEGIN_COMMENT
    <<DUDA>>
    Entre la posicion=8,9 de la secuencia, el cursor se queda en el *frame 1* porque da vuelta dos veces (?)
    por eso no queda en el *frame 2* ?
    #+END_COMMENT

    #+BEGIN_QUOTE
    Entre las ultimas dos posiciones de la secuencia,
    se quiere acceder a la *pagina 2* que ya está cargada en memoria,
    y además el *bit de uso* ya está en ~u=1~ por tanto queda igual a la posicion anterior a la última

    si.. el *bit de uso* hubiese estado en ~u=0~ entonces sólo se habilitaba cambiando a 1
    #+END_QUOTE
*** Ejemplo - Bit de uso
    #+BEGIN_QUOTE
    Entre la posicion=1,2 de la secuencia.. como en la posicion=2 se quiere acceder a la *pagina 5*
    y ya está en memoria (porque en la posicion anterior aparece),

    entonces solo modificamos su *bit de uso* pasando de ~u=0~ a ~u=1~
    ó bien en la tupla ~(u=0,m=1)~ a ~(u=1,m=1)~
    #+END_QUOTE
    
    |         | 4 '       | 5         |
    |---------+-----------+-----------|
    | frame 1 | 5^(0,1)   | ~5^(1,1)~ |
    | frame 2 | 4^(1,1)   | 4^(1,1)   |
    | frame 3 | ->2^(1,0) | ->2^(1,0) |
* Estrategia Page Buffering
** Conceptos
   1. Reduce la cantidad de operaciones a disco
   2. Se mantienen un *pool de frames libres* (espacio en memoria, frames que no tienen asignados páginas de procesos)
   3. El pool de frames es un espacio de RAM que reservamos/retenemos para agilizar cuando existen dos operaciones de disco
   4. Estos frames son como buffers para guardar información temporalmente
   5. La cantidad frames reservados puede ir variando, pero nunca es mayor a la que se estableció al inicio

   #+BEGIN_QUOTE
   El problema que soluciona, es cuando existen por ejemplo dos operaciones de disco.
   Las operaciones de disco son costosas (porque es tiempo esperando..),
   demorando la asignación de espacio en memoria a un proceso (el encontrar un frame donde colocar la página del proceso)

   Dos operaciones de disco porque
   1. Para liberar un frame (*operación de escritura*)
   2. Para luego cargarle la página que queremos acceder (implíca una *operación de lectura*, para cargar la página)
   #+END_QUOTE
** Ejemplo - Proceso de Traducción + Algoritmo de Clock Modificado
  #+BEGIN_QUOTE
  Si ocurre TLB MISS -> P=0 -> está dentro del espacio de direcciones -> no hay marco libre -> M=1 (bit modificado, página tuvo una operación de escritura)

  Se lanza una Interrupción de E/S para una operación de escritura, para guardar los cambios en SWAP (disco),
  para que cuando se carge la Página tenga esos cambios.

  Mientras ocurre la Interrupción de IO, el proceso queda bloqueado..
  Cuando termina la Interrupción de IO, el proceso pasa a READY y puede volver a ser seleccionado

  Por ejemplo en el *algoritmo Clock Modificado* tenemos
  | Secuencia de páginas      | 2          | 4'        |
  |---------------------------+------------+-----------|
  | BITS                      | P U M      | P U M     |
  |---------------------------+------------+-----------|
  | FRAME 1                   | ->5^(1,1)  | 5^(0,1)   |
  | FRAME 2                   | ~3'^(0,1)~ | ~4^(1,1)~ |
  | FRAME 3                   | 2^(1,0)    | ->2^(1,0) |

  en la posicion=1,2 de la secuencia de páginas, el frame (2) tiene la *página 3* con (u=0, m=1)
  por tanto el algoritmo la elige como víctima a ser sustituida por la *pagina 4*,
  porque tiene el *BIT de uso* en ~u=0~ (recordando que la prioridad para elegir víctima es segun la tupla (m,u) está en este orden (0,0) (0,1), (1,1))
  
  pero...! como el *BIT de modificado* lo tiene en ~m=1~, antes de ser sustituída se debe realizar una *operación de escritura* (acceso a disco/swap)
  para guardar los cambios.. y mientas ocure eso, el proceso que contiene esa página quedará bloqueado,
  cuando termine la interrupción de IO (se guardaron los cambios en disco), ese proceso vuelve a la cola de READY para ser elegido
  pudiendo acceder a sus páginas..

  este escenario es costoso porque provoca 2 accesos a disco (lectura para traer la página 4 de disco, escritura para guardar los cambios de la página 3)
  pero...! se puede optimizar los accesos a disco usando la estrategia de *Page Buffering* teniendo un *pool de frames libres*
  que nos reservabamos una cant. de frames (espacio en memoria) pero no para la asignación de procesos si no que sólo para estos casos
  #+END_QUOTE
* Estrategia Lockeo de Paginas
  - Esta operación de lockeo la realiza el *SO*
  - Ocurre cuando proceso se bloquea esperando una IO
  - Se evita sustituir páginas que forman parte de una E/S
  - Permite habilitar un *BIT de LOCKEO sobre un Frame* para que NO pueda ser reemplazado durante una operación de IO 
   
