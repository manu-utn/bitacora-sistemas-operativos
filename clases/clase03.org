#+TITLE: Clase 03 - Planificación de Procesos/Hilos

1º PARCIAL 05/06 (Junio)

Clase 3 22:40 - algoritmo sfj/priori/hrn/... natasha
(hace el diagrama del sfj con desalojo para comparar)
https://drive.google.com/drive/u/0/folders/1juNoOWbHWaBKeAi-TUAawo0hMklaSVuC

video:
https://drive.google.com/file/d/11R3_kSnbHcTy2-KYJZWzKczbd9inkhBo/view

[[file:clase02.org::*Swapping][swapping]]

* repaso zoom
  + en los GANTT no se grafican los *cambios de modo* 
    porque el SO ya comienza con ese cambio de modo, eso es a nivel hardware
  + cuando un proceso invoca a un wrapper para una syscall
    puede suceder un *switch process*
  + *afinidad* es...
  + la *caché* pertenece a la CPU, y puede guardar 
** Preguntas realizadas
*** Pregunta 1
    estaria bien justificar que es el PLP lo mueve a Ready y el PCP a Running?
    o solo basta con decir que es el SO?
    
    *Respuesta:*
    En este caso bastaría con decir que es el SO.
    La realidad es que tendrías razón solo si el SO en cuestión tiene 
    Planif a Largo Plazo no todos los SO tienen planif. a largo y 
    a mediano plazo,
    pero.. si todos los SO tienen Planif. a corto plazo (o dispatcher) 
*** Pregunta 2
    
* Repaso clase 02
** Sistemas multiprogramados
** Programa Vs. Proceso
** Atributos de procesos
** Imagen de un proceso
   |---------|
   | proceso |
   |---------|
   | stack   |
   | heap    |
   | datos   |
   | codigo  |
   | pcb     |
   |---------|

   |----------|
   | programa |
   |----------|
   | codigo   |
   |----------|
*** heap
    - memoria dinamica
    - usamos malloc y free
    - si no liberamos memoria, puede pasar *memory leaks*
*** datos
*** codigo
*** pcb
    contiene información del proceso 
    - información del contexto
** creacion de un proceso 
*** fork
*** otros
    el proceso creado se debe agregar en una cola
    de planificación
** Ciclo de vida de un proceso
*** diagramas de estado
**** new
     primer proceso q se crea
**** ready
**** cpu (running/ejecutando)
     cpu porque está ejecutando en el cpu (procesador)
**** exit
**** blocked
     - cuando se necesita leer algun archivo
     - los dispositivos e/s son más lentos que el cpu
       por eso muchos procesos estan en estado *bloqueado*
** cambio de proceso
** otros 
  Cuando tenemos un solo procesador, 
  pueden haber muchos programas ejecutando en el
  mismo intervalo (osea de manera *concurrente*
  pero NO en *paralelo*, para eso se necesitan
  más de un nucleo)

* Prioridad Procesos
  - Al tener un solo procesador, es necesario asignar prioridades
  - El *procesador* es un recurso limitado
  - Es el *sistema operativo* quien designa las prioridades
* Ciclo de rafagas
** Conceptos
   - Cuando un proceso inicia su ciclo de vida pasa por ciclo
     de rafagas de CPU, luego de E/S, y se repite..
   - En cada rafaga de CPU y E/S quiere decir que cambia de estado
     de *Ejecutando* (en CPU) a *Bloqueado* (por una E/S) y asi va rotando..
     (con algunas esperas mientras está ready para ejecutar)

   *Observación:*
   - Un procesos del tipo *CPU-Bound* no tiende a ser luego *IO-Bound*
     y viceversa
** CPU-Bound (limitados por cpu)
   - Son procesos que usan mucho tiempo del *CPU* y un poco de *E/S*

   #+BEGIN_EXAMPLE
   Procesos que requieran mucho cálculo
   #+END_EXAMPLE
** IO-BOUND (Limitados por E/S)
   - Son procesos que usan mucho de *E/S* y un poco de *CPU*

   #+BEGIN_EXAMPLE
   el microsoft word podria ser un IO-BOUND porque se queda esperando
   que el usuario escriba

   el entorno gráfico podria ser, porque usa mucho la placa de video
   
   también programas que sincronizan archivos en la nube (dropbox)
   #+END_EXAMPLE
* Planificador - Objetivos
  - Asigna procesos para ser ejecutado en la CPU (administrado por dif. colas READY-BLOCKED)
  - Decide cual es el próximo proceso que se debe ejecutar
  - Decide donde ubicar el *PCB del proceso* en ejecución
  - Cada planificador prioriza las siguientes *métricas* de manera diferente
    - Tiempo de respuesta
    - Eficiencia de CPU
    - Throughput (nivel de procesamiento)
* Tipos de Planificadores
   En el Diagrama de 7 estados
** Conceptos
** Grado de multiprogramación
   - Max. cant. de procesos en ejecución, osea que usen CPU
     (de *forma recurrente*)
** [DOING] (PLP) Planificador de Largo Plazo
   - Controla el *grado de multiprogramación* del sistema
   - Decide que *job* será aceptado y convertido en *proceso*
     - idle (?)
     - cpu bound / io bound (?)
   - Es el diagrama de 2 estados, que contiene
     + Estado Nuevo (new)
     + Estado Finalizado (exit)

   *Obsevación:*
    - Cuando pasa a *Estado Exit* se guarda el PCB del proceso
    - Cuando un proceso finaliza, baja el [[Grado de Multiprogramación]]
    - El PCB siempre está en memoria
** (PMP) Planificador de Mediano Plazo
*** Conceptos
   + Realiza tareas de [[file:clase02.org::*Swapping][Swapping]] (ó intercambio) osea Swap-in y Swap-out
   + (Swap-out) Decidir cuando suspender un proceso (guardarlo a un almacenamiento secundario)
   + (Swap-in)  Decidir cuando volver a cargar a RAM un proceso (despertarlo)
*** Estados
   Es el diagrama de 5 estados, pero los más importantes son
    + Estado Listo-Suspendido (ready-suspend)
    + Estado Bloqueado-Suspendido (blocked-suspend)

    *Observación:*
    - Estos procesos pueden pasar a los estados del de [[Planificador de Corto Plazo][Corto Plazo]]
      (ready/running/blocked)
** [DOING] (PCP) Planificador de Corto Plazo
*** Conceptos
    + Monitorea...
    + Se ejecuta muy frecuentemente, todo el tiempo se ejecuta
    + Es invocado cuando
      - ocurre un evento que *libera el CPU*
      - debe seleccionar un *proceso más prioritario*
*** Clasificación (Con/Sin Desalojo)
    + Con desalojo: apropiativo
    + Sin desalojo: no apropiativo, cooperativos
*** Eventos de replanificación
    + Interrupciones I/O
    + LLamadas al sistema
    + Señales

    Cuando la CPU está liberada
    + Proceso finaliza (Running -> Finished)
    + Proceso se bloquea (Running -> Blocked)
    + Proceso cede voluntariamente la CPU (Running -> Ready)

    Cuando conviene elegir otro proceso, 
    en particular los Planificadores que usan *con desalojo*
    + Proceso recibe evento esperado (Blocked -> Ready)
      - Puede ser una ~syscall~
      - Puede ser una *interrupción*
    + Proceso nuevo (Syscall: New -> Ready)
    + Interrupción por timer-clock (por ~quantum~ a nivel de hardware)
*** Estados
    Es el diagrama de 3 estados, pero los más importantes son
    + Estado Listo (ready)
    + Estado Ejecutando (running/cpu)
    + Estado Bloqueado (blocked)
*** Diagrama
    #+BEGIN_SRC plantuml :file img/planificador-corto-plazo.png
      [*]
    #+END_SRC
*** Elegir proximo proceso y donde ubicar PCB
    - decide cual será el proximo proceso a ejecutar
    - donde ubicar el PCB del proceso en ejecución
    - si hay procesos bloqueados, se sabe el motivo

    Puede pasar de estado *bloqueado* a *ready* y luego *cpu* porque...:
    - le puse el comando =sleep()=
    - usar semaforos
*** Porque planificamos (Criterios)
    #+BEGIN_COMMENT
    Throughput (sistema)
    #+END_COMMENT

**** Prestaciones (cuantitavo/medibles)
***** orientados al usuario/proceso
      + tiempo de ejecución (ó turnaround time)
        - es el proceso desde que inicié un proceso hasta que finalizó
      + tiempo de respuesta
        - cuanto tiempo tarda el sistema en responder ante una operación del usuario
      + tiempo de espera
        - es la suma de todos los tiempos en los que el proceso estuvo
          en la cola de listo (el proceso espera que el SO lo elija)
        - tiempo que se le niega en usar la CPU
***** orientados al sistema
      Pueden afectar a todos los procesos
      + tasa de procesamiento (rendimiento/throughput)
        - cantidad de procesos que terminaron en una unidad de tiempo
      + utilización de cpu (en %)
        - cuanto se utilizó en un tiempo determinado

      #+BEGIN_EXAMPLE
      Si la utilización de CPU tiene un % no es bueno,
      (por algún proceso colgado)
      #+END_EXAMPLE
**** Otros (cualitativos)
***** orientados al usuario/proceso
      + previsibilidad
         - lo que un usuario prevee/cree que sucederá

      #+BEGIN_EXAMPLE
      Un usuario que abre una aplicación que se demora más
      de lo que debería
      
      El usuario no se esperaba que sucediera eso,
      es algo imprevisible, no se puede medir
      #+END_EXAMPLE
***** oientados al sistema
      + equidad
        - que varios procesos se ejecuten al mismo tiempo
          (aunque no es del todo cierto, porque solo se puede
          ejecutar uno por vez)
      + imposición de prioridades
      + equilibrado de recursos
* Algoritmos
** Conceptos
   - siempre elegiremos los que tengan mayor *prioridad*
   - se ordenan los procesos en una *Cola de Listo* esperando a 
     ser ejecutados por el cpu, para saber cual elegir
  
   *Importante:*
   - Siempre que un proceso termine su *E/S* pasa a la *cola de listos*

   *Observaciones:*
   - Cuando un proceso está en E/S queda en *estado bloqueado*
     porque está esperando que ese dispositivo finalize
** [DOING] (FCFS/FIFO) First Come First Served
*** Ventajas
    - facil de implementar
    - tiene poco *overhead*
*** Desventajas
    - NO optimiza metricas (throughput, tiempo de espera, tiempo de respuesta,...)

    *Observación:*
    - El throughput es el nivel de procesamiento, cuantos procesos se ejecutaron 
      en una unidad de tiempo
*** Conceptos
    - es *sin desalojo*
    - la elección del próximo proceso es el tiempo de llegada
    - la prioridad es śegun el que más lleva tiempo
      está esperando en la *cola de listos*
    - el próximo proceso sera el que más tiempo se quedó esperando

    *Observación:*
    + Un proceso puede dejar de ejecutar cuando
      - ocurre una *interrupción*
      - por una *llamada al sistema* (ó syscall)
        (Ej. exit, sleep, etc..)
      - ó porque termina su tiempo de ejecución
*** [DOING] Momentos de Replanificación
    
*** Ejemplo
    Un ejemplo hipotécico de 3 procesos que compiten por usar el CPU
    habiendo un único procesador
    y un único dispositivos de Entrada/Salida

   |----+----+-----+----+-----|
   |    | LL | CPU | ES | CPU |
   |----+----+-----+----+-----|
   | P1 |  0 |   4 |  2 |   1 |
   |----+----+-----+----+-----|
   | P2 |  1 |   2 |  3 |   3 |
   |----+----+-----+----+-----|
   | P3 |  2 |   1 |  3 |   2 |
   |----+----+-----+----+-----|


   *Referencias de la tabla:*
   + LL: Instante de llegada del proceso a la *cola de listos*
   + CPU: Rafagas de cpu
   + ES: Rafagas de E/S
   
   *Observaciones:*
   En el diagrama de planificación de este ejemplo
   la E/S no se pueden solapar porque hay solo UN dipositivo de E/S

   #+BEGIN_SRC plantuml :file img/fcfs-1.png
     @startuml
     Title First Come First Served (FCFS)

     concise "Proceso 1" as P1
     concise "Proceso 2" as P2
     concise "Proceso 3" as P3

     @0
     P1 is CPU

     @+4
     P1 is "E/S"
     P2 is CPU

     @+2
     P1 is {hidden}
     P2 is "E/S"
     P3 is CPU

     @+1
     P1 is CPU
     P2 is "E/S"
     P3 is {hidden}

     @+1
     P1 is {hidden}
     P2 is {hidden}
     P3 is "E/S"

     @+3
     P3 is CPU

     @+2
     P3 is {hidden}
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:img/fcfs-1.png]]
   
** (SJF) sin desalojo ó (SPN) Short Job First
*** Conceptos
    - Lo llamaremos *Primero con rafaga más corta*
    - la prioridad es el que tenga rafaga de cpu mas corta
    - el sistema operativo intervino cuando hubo
      - una *llamada al sistema*
      - ó una *interupción* (cambio de modo)
*** Replanifica cuando
    + Libera CPU
*** Desventajas
    - Puede generar *Inanición* (ó Starvation, que un proceso nunca se ejecute)
    - Que un proceso monopolice la CPU
*** Ventajas
    + Mejora el Throughput
    + Mejora el T de espera promedio
    + Mejora el T de respuesta
*** Ejemplo
   |----+----+-----+----+-----|
   |    | LL | CPU | ES | CPU |
   |----+----+-----+----+-----|
   | P1 |  0 |   4 |  2 |   1 |
   |----+----+-----+----+-----|
   | P2 |  1 |   2 |  2 |   3 |
   |----+----+-----+----+-----|
   | P3 |  2 |   1 |  1 |   2 |
   |----+----+-----+----+-----|

   *Referencias de la tabla:*
   + LL: Instante de llegada del proceso a la *cola de listos*
   + CPU: Rafagas de cpu
   + ES: Rafagas de E/S

   *Observaciones:*
   - En el diagrama de planificación de este ejemplo
     la E/S no se pueden solapar porque hay solo UN dipositivo de E/S
   - Cuando un proceso está en E/S queda en *estado bloqueado*
     porque está esperando que ese dispositivo finalize
  
   *Importante:*
   - En el instante 9, por medio de una *interrupción*
     se le avisa al *procesador* que la E/S del *proceso (2)*
     finalizó por una *interrupción* el SO interviene,
     y hace que pase del *estado bloqueado* al *estado listo*

   *Momentos en los que intervino el Sistema Operativo:*
   - Siempre que hubo un *cambio de modo* (syscall)
   - En los instantes 0, 1, 2 porque se *crearon los procesos* p1,p2,p3
     (por una syscall, "quizás" un ~fork()~)
   - En los instantes 4,5,7,8,10,13 porque hubo una *syscall*
     que al estar seguido de una E/S pudo haber sido
     - un ~read()~ donde el wrapper es ~fread()~ 
     - ó tmb un ~write()~ que su wrapper es ~fwrite()~  
       (Obs: ~printf()~ tambien es wrapper de write() )
   - En los instantes 6,7,9 hubo una *interrupción*
     (por los dispositivos de E/S avisando que finalizaron)
   - En el instante 7 sucedieron dos cosas
     1. El proceso 3, hubo una *interrupción* del dispositivo de E/S
        hacia al *procesador* avisando que finalizó
     2. El proceso 2, hizo una *syscall* porque finalizó
     3. El *sistema operativo* ejecutó el *planificador a corto plazo* 
        y eligió el *proceso 1* a ejecutar
        

     El P1 a ejecucion, el P2 a bloqueado y el P3 a la cola de listos
** (SJF) Con desalojo ó (SRT)
*** Prioridad
    - El *Criterio de prioridad* es el siguiente que tenga 
      menos rafagas de CPU
    - Se elije al proceso siguiente *con la rafaga más corta*
*** Conceptos
    - por cada ejecución se le resta uno a las rafaga de CPU
    - si tienen misma prioridad, se aplica FIFO
      (el que ejecutaba, sigue ejecutandose)
    - Cada vez que se agrega un proceso a la *cola de listos*
      se debe evaluar si hay otro con mayor prioridad
      (osea con menos ráfagas de cpu)
*** Replanifica cuando
    + Libera CPU (libera los recursos asignados de un proceso)
    + Un nuevo proceso
    + Un poceso se desbloquea
*** Ventajas
    - Garantiza prioridades 
*** Desventajas
    - Puede generar *Inanición* (ó Starvation, que un proceso nunca se ejecute)
    - Que un proceso monopolice la CPU
*** Formula de estimación
    Est(n+1)=alfa*TE + (1-alfa)*Est(n)	
     
    - Est(n):   Estimado de la Rafaga Anterior
    - TE(n):    Lo que realmente ejecutó la rafaga anterior en la CPU
    - Est(n+1): Estimado de la Rafaga Siguiente

    alfa * rafaga_anterior + (1-alfa) * estimacion_anterior

    *Observación:*
    - Conviene un alfa mas chico para rafagas estables
    - Conviene un alfa mas grande para rafagas más cambiantes
*** Ejemplo
   |----+----+-----+----+-----|
   |    | LL | CPU | ES | CPU |
   |----+----+-----+----+-----|
   | P1 |  0 |   4 |  2 |   1 |
   |----+----+-----+----+-----|
   | P2 |  1 |   2 |  2 |   3 |
   |----+----+-----+----+-----|
   | P3 |  2 |   1 |  3 |   1 |
   |----+----+-----+----+-----|

   *Referencias de la tabla:*
   + LL: Instante de llegada del proceso a la *cola de listos*
   + CPU: Rafagas de cpu
   + ES: Rafagas de E/S
** (RR) Round Robin
*** Conceptos
   - Entra en la categoría de *con desalojo*
   - *Quantum* es cuanto o rafaga de tiempo
   - Cola de procesos listos es *FIFO*
   - la rafaja es la misma para todos los procesos
   - Es el sistema operativo configura el reloj
   - Utiliza *interrupciones de clock* para *desalojar*
     a los *procesos* del procesador cada X tiempo
     (si el proceso tenia cosas por hacer 

   #+BEGIN_QUOTE
   si el *quantum* es muy chico ej. q=1
   habrá un =overhead= osea el kernel va a intervenir a cada rato

   si el *quantum* es muy grande ej. q=5
   el RR actuará igual a un FIFO
   #+END_QUOTE

   #+BEGIN_EXAMPLE
   En los algoritmos "sin desalojo" como el FIFO
   
   aquellos procesos que tengan "rafagas muy largas"
   van a usar mucho tiempo el CPU (se lo apropian)

   mientras que los que tengan "rafagas cortas"
   permiten que otros procesos pueda usar el CPU
   #+END_EXAMPLE
*** Diagrama de Estados
    #+BEGIN_SRC plantuml :file img/round-robin.png
      @startuml
      Title Round Robin (RR)
      [*] -r-> Nuevos
      Nuevos -r-> Listos
      Listos -r-> CPU
      CPU -d-> Bloqueados
      Bloqueados -u-> Listos
      CPU -l-> Listos
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/round-robin.png]]
*** Replanifica cuando
    + Libera CPU
    + FIN de Quantum (interrupción por timer, a nivel hardware)
*** Ventajas
    + respeta el orden de llegada (FIFO/FCFS)
    + Permite que todos ejecuten *concurrentemente* 
*** Desventajas
    + Puede generar MUCHO *overhead* osea *process switch*
*** Ejemplo
    COn quantum = 3

   |----+----+-----+----+-----|
   |    | LL | CPU | ES | CPU |
   |----+----+-----+----+-----|
   | P1 |  0 |   4 |  2 |   4 |
   |----+----+-----+----+-----|
   | P2 |  1 |   4 |  2 |   3 |
   |----+----+-----+----+-----|
   | P3 |  2 |   3 |  2 |   3 |
   |----+----+-----+----+-----|
** (VRR) Virtual Round Robin
*** Conceptos
   *IMPORTANTE:*
   En la cola Auxiliar-Listos, van a ir todos los que les faltó terminar su *quantum*
   (tanto los CPU-Bound como I/O-Bound)

   - Con *desalojo*
   - COn *quantum* de tiempo
   - Con interupción de reloj
   - dos colas de procesos listos para ejecutar
     (por tanto tiene una *cola auxiliar*)
   - mejora el rendimiento para pocesos I/O-BOUND ante los CPU-Bound
     (las E/S son mucho mas lentas)
   - cuando se termina todo su *quantum* irá a la cola de *listos*
   - los procesos de menor prioridad (los que están en la Cola de Auxiliar-Listos)
     se ejecutan luego de que se ejecuten TODOS los de mayor prioridad

   #+BEGIN_EXAMPLE
   q: quantum
   s: tiempo en cpu
   q* = q-s
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
   Problema del Round Robin con los procesos
   Cuando el quantum es muy chico, los procesos I/O-Bound se ven perjudicados
   porque al usar poco el CPU y más los I/O
   habrá un *overhead* donde los procesos se van intercalando 
   en el uso del CPU, y los I/O no llegan a realizar su I/O
   #+END_EXAMPLE
*** Diferencias con el (RR) Round Robin
    - En el *RR* la rafaga se mantiene
    - Resuelve el poblema de *RR* que perjudicaba a los procesos I/O-bound
    - Aparece una *Cola Auxiliar de Listos*
      donde los *procesos bloqueados* tienen *mayor prioridad*
      (tanto los I/O-Bound como los CPU-Bound)
    - En el (RR) los procesos que tenian menor prioridad 
      no podian competir con los otros de mayor prioridad
      y nunca se terminaban de ejecutar
*** Diagrama de Estados
    #+BEGIN_SRC plantuml :file img/virtual-round-robin.png
      @startuml
      Title Virtual Round Robin (VRR)
      [*] -r-> Nuevos
      Nuevos -r-> Listos : q
      Listos -r-> CPU
      CPU -d-> Bloqueados : llamada al sistema
      Bloqueados -u-> Auxiliar_Listos : q*
      Auxiliar_Listos -u-> CPU
      CPU -l-> Listos : q

      note bottom of Listos : Se les asigna el quantum original
      note left of Bloqueados : q=quantum\ns=tiempo en cpu\nq*=q-s\n\nse les asignará lo que les faltó\npara terminar el quantum
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/virtual-round-robin.png]]

** (HRRN) Highest Ratio Response Next
*** Conceptos
    - Es un algoritmo del tipo *Sin desalojo*
    - Significa "Primero el de mayor tasa de respuesta"
    - aging (envejecimiento)
*** Criterio de Prioridad
    + prioriza a los de menor rafaga

    + (+) prioridad: a mayor es W => mayor RR => mayor sera el tiempo de espera
    + (-) prioridad: a menor es S => menor RR =>menor será la duración de ráfaga
*** Replanifica cuando
    + Libera CPU
*** Ventajas
    + Prioriza procesos IO-Bound
       sin generar *starvation* (inanición)
*** Desventajas
    + Genera MUCHO *overhead*
      * porque necesita hacer muchos cálculos
      * intenta estimar la duración de la prox. ráfaga
    + Requiere estimación
*** Formula
     RR = (W+S) / S  => RR = 1+W/S
     
     *Observación:*
     NUNCA va a tener un valor menor a 1
        

    |--------------------+-----------------------------------|
    | W (wait time)      | tiempo esperando en Ready         |
    |--------------------+-----------------------------------|
    | S (service time)   | - duración de prox. rafaga de cpu |
    |--------------------+-----------------------------------|
    | RR (ratio response) | tasa de respuesta                 |
    |--------------------+-----------------------------------|
** Colas Multinivel
*** Conceptos
    - Aparecen varias colas *Ready* con *distintas prioridades*
    - se clasifican los procesos por tipos
    - cada cola usa su propio algoritmo de planificación
    - Los procesos se ejecutan por prioridad, quedando la *cola de listos*
      1) Cola Prioridad Máxima
      2) Cola Prioridad Media
      3) Cola Prioridad Baja

    *Importante:*
    - Un proceso que termina de ejecutar, vuelve a la misma cola donde estaba
*** Ejemplo
    |-----------+------------------------------------------+-------------------|
    | Prioridad | Cola                                     | Posible Algoritmo |
    |    <c>    |                                          |                   |
    |-----------+------------------------------------------+-------------------|
    |     1     | Cola Clase (1) para Procesos del Sistema | Round Robin       |
    |-----------+------------------------------------------+-------------------|
    |     2     | Cola Clase (2) para Procesos de Usuario  | SJF               |
    |-----------+------------------------------------------+-------------------|
    |     3     | Cola Clase (3) - Procesos                | Round Robin       |
    |-----------+------------------------------------------+-------------------|
    |     4     | Cola Clase (4) -                         | FCFS/FIFO         |
    |-----------+------------------------------------------+-------------------|
** Colas multinivel realimentado (ó Feedback)
*** Conceptos
    - si hay *desalojo* por *interrupción de reloj* baja su prioridad
    - cada cola usa su propio algoritmo de planificación
    - el *sistema operativo* puede elegir sus propias reglas,
      para hacer un algoritmo mas complejo
      * definir la cantidad de colas
      * el algorito que usará cada cola
      * si habrá desalojo o no en las colas
      * definir en que momento un algoritmo aumenta/baja la prioridad
        (por tanto existe una técnica de *anging*)
*** Ejemplo 1
      |-----------------------------------|
      | Cola Prioridad Máxima (quantum=2) |
      |-----------------------------------|
      | Cola Prioridad Media (quantum=4)  |
      |-----------------------------------|
      | Cola FCFS/FIFO                    |
      |-----------------------------------|
*** Ejemplo 2
    - Los procesos se ejecutan por prioridad, quedando la *cola de listos*

      |-----------------------------------|
      | Cola Prioridad Máxima (quantum=2) |
      |-----------------------------------|
      | Cola Prioridad Media (quantum=4)  |
      |-----------------------------------|
      | Cola Prioridad Baja (quantum=8)   |
      |-----------------------------------|

    #+BEGIN_EXAMPLE 
    Cuando un proceso de *prioridad máxima* termina todo su *quantum*     
    entonces pasa a la *cola de prioridad media*
   
    pero.. si NO termina todo su *quantum* vuelve a la
    *Cola de prioridad máxima* hasta terminarlo
    #+END_EXAMPLE

    #+BEGIN_QUOTE
    Podemos aplicar un mecanismo de Anging
    en los procesos de la *Cola de Prioridad Baja*
    para cuando terminen todo su quantum
    puedan ir a la *Cola de Prioridad Máxima*
    para evitar su Inanición
    #+END_QUOTE
** Conceptos
*** Simultaneidad de eventos en Ready
   - puede que varios procesos llegen en simultáneo a la cola de *Listos*
   - aplica para todos
   
   La prioridad se manejará por
   1. interrupción de reloj
   2. interupción por finalización de evento 
      (Ej. lectura/escritura de disco ó de socket)
   3. llamada al sistema

   #+BEGIN_SRC plantuml :file simultaneidad-en-ready.png
     @startuml
     [*]
     Nuevos -r-> Listos : (3) Llamada al Sistema
     Bloqueados -u-> Listos : (2) Interrupción por\nFinalización de Evento
     CPU -l-> Listos : (1) Interrupción de Reloj
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:simultaneidad-en-ready.png]]

*** Inanición (starvation)
    Situación en la que a un proceso se le niega la posibilidad de usar 
    un recurso (Ej. el procesador) por haber otos procesos con 
    mayor prioridad

    *Observación:*
    En el *(FCFS, First come First Serve)* que implementa FIFO no sucede,
    porque el criterio de prioridad es por llegada,
    osea el que lleva más tiempo en la *cola de listos* de ejecutar.

    #+BEGIN_EXAMPLE
    Referencia de alguno de los libros de que en una universidad había
    una computadora con un proceso que se demoró 6 años en poder ser
    ejecutado, porque el resto de los procesos tenían mayor prioridad
    #+END_EXAMPLE
*** Estimación de Ráfaga
    - estadísticas
    - fórmula del promedio exponencial

      #+BEGIN_EXAMPLE
      EST(n+1)=alfa * TE(n) + (1-alfa) * EST(n)

      TE: Tiempo de ejecución de la rafaga actual
      EST(n): Tiempo estimado para la rafaga actual
      EST(n+1): tiempo estimado para la proxima rafaga 
      alfa: constante entre 0 y 1
      #+END_EXAMPLE
*** Anging (Envejecimiento)
    Definir el método de *Anging* es cualquier método que se le ocurra
    al diseñador para hacer que un proceso que tenía *baja prioridad*
    después de un tiempo tenga *mayor prioridad*

    puede suceder porque
    - por la fórmula
    - ó porque el algoritmo decide que cuando el proceso termine todo
      su *quantum* entonces *aumente su prioridad*
** Categorías de Algoritmos (Con/Sin desalojo)
*** Sin desalojo (sin explusión ó Nonpreemptive)
    - significa sin desalojo del procesador
    - el sistema operativo no puede hacer para que ese proceso deje de usar
    - es un proceso que hizo una *syscall*
    - Los algoritmos que entran en esta categoría son
      1) FCFS
      2) SJF
     
    #+BEGIN_EXAMPLE
    Si el algoritmo tiene un while(1) osea un loop infinito,
    el sistema operativo no lo puede detener
    #+END_EXAMPLE
*** Con desalojo o con expulsión (con expulsión o Preemptive)
    - un proceso que aun no hizo una *llamada al sistema*
    - implica que haya mas *overhead*
    - el sistema operativo puede intervenir y decidir si ese proceso
      puede seguir ejecutando o no 

    - Los algoritmos que entran en esta categoría son
      1) RR 
* [DOING] Tips Algoritmos
** (RR) Round Robin
   Se desalojan los procesos por *quantum*
   + es el *timer* el que genera una *interrupcion de quantum*
     - es el SO el maneja esa *interrupcion*
     - el timer es a nivel hardware
     - es seteado por el *planficador*
     
     
   + Se vuelve a replanificar siempre en cuando
     * Cuando un proceso de *bloquea* osea una *interrupción de IO*
     * Cuando un proceso termina
     * Cuando salta una *interupción de quantum*
       (vuelve la cola de ready, al final)
** (VRR) Virtual Round Robin
   Aparece el *quantum variable* 
   Los procesos *bloqueados* pasan a una cola *prioritaria*
      + tienen más prioridad que los de CPU
      + ejecuta el *quantum* que le faltaba
** Interrupciones
   + Pueden suceder dos o mas interrupciones al mismo tiempo
     (Ej. Una interrupcion por fin de IO, y una por Quantum)
   + Es el *sistema operativo* quien atiende las *interrupciones*
     con los *handlers*
   + Prioridades
     1. Interrupción de Quantum
     2. Interrupción de IO
** Planificadores
   - son parte del SO
* [DOING] COnceptos importantes
** que es el tiempo de espera
   es el tiempo que un proceso está en la cola de espera
   (esperando por la cpu)
** El SJF
   - minimiza el tiempo de espera promedio
   - NO es cierto que produce poco overhead
** En RR
** Que algoritmos podrian sufrir de Inanición
   - SFJ
   - Por prioridades
   - feedback
** [TODO] hilos - klt y ult
   un proceso que tiene 3 *KLTs* con 3 *ULTs* asociados
   si un ULT realiza una Syscall bloqueante (ej. read)
   se cumple que

   1. Por default todo KLT se bloquea
      - si NO hay *jacketing* se va a bloquear
   2. podria NO bloquearse todo el KLT
      - en el caso que se use *jacketing*
   3. al finalizar la operación bloqueante y ser seleccionados
      por el *planificador* del SO vuele 
      - poque no iba a tener manera de replanificar
   4. al finalizar la operación bloqueante y ser seleccionados por 
      el planificador del SO ejecuta el ULT que seleccione la 
      biblioteca de ULTS
      - en caso de que lo haya hecho a traves de la biblioteca
      - 

   *Observación:*
   - los 3 klt representan 3 hilos


   
   
